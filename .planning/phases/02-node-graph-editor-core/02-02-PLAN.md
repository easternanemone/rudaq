---
phase: 02-node-graph-editor-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/daq-egui/src/widgets/node_palette.rs
  - crates/daq-egui/src/widgets/mod.rs
  - crates/daq-egui/src/graph/viewer.rs
  - crates/daq-egui/src/graph/validation.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true

must_haves:
  truths:
    - "User can see a palette of node types (Scan, Acquire, Move, Wait, Loop)"
    - "User can drag a node type from palette onto the canvas"
    - "User can draw a wire from one node's output to another node's input"
    - "Invalid connections are rejected with visual feedback"
  artifacts:
    - path: "crates/daq-egui/src/widgets/node_palette.rs"
      provides: "Draggable node type palette"
      contains: "NodePalette"
    - path: "crates/daq-egui/src/graph/validation.rs"
      provides: "Connection validation logic"
      contains: "validate_connection"
    - path: "crates/daq-egui/src/graph/viewer.rs"
      provides: "Updated SnarlViewer with connect validation"
      contains: "fn connect"
  key_links:
    - from: "crates/daq-egui/src/widgets/node_palette.rs"
      to: "crates/daq-egui/src/graph/nodes.rs"
      via: "ExperimentNode::default_* constructors"
      pattern: "ExperimentNode::"
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/widgets/node_palette.rs"
      via: "NodePalette widget rendering"
      pattern: "NodePalette"
---

<objective>
Implement the node creation workflow through a draggable palette and wire connection functionality with validation.

Purpose: This plan enables the core visual editing interaction - users can actually build experiment graphs by placing nodes and connecting them. Without this, the canvas remains empty and non-functional.

Output: Users can drag nodes from a palette onto the canvas and connect them with validated wires.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-node-graph-editor-core/02-RESEARCH.md
@.planning/phases/02-node-graph-editor-core/02-01-SUMMARY.md

# Graph module from Plan 02-01:
@crates/daq-egui/src/graph/mod.rs
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/graph/viewer.rs
@crates/daq-egui/src/panels/experiment_designer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NodePalette widget with draggable node types</name>
  <files>
crates/daq-egui/src/widgets/node_palette.rs
crates/daq-egui/src/widgets/mod.rs
  </files>
  <action>
Create the NodePalette widget that displays available node types for drag-and-drop:

**node_palette.rs:**

```rust
use egui::{Ui, Response, Sense, Color32, Rounding, Vec2};
use crate::graph::ExperimentNode;

/// A node type that can be dragged from the palette
#[derive(Clone, Copy, Debug)]
pub enum NodeType {
    Scan,
    Acquire,
    Move,
    Wait,
    Loop,
}

impl NodeType {
    pub fn all() -> &'static [NodeType] {
        &[Self::Scan, Self::Acquire, Self::Move, Self::Wait, Self::Loop]
    }

    pub fn name(&self) -> &'static str {
        match self {
            Self::Scan => "Scan",
            Self::Acquire => "Acquire",
            Self::Move => "Move",
            Self::Wait => "Wait",
            Self::Loop => "Loop",
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            Self::Scan => "Sweep a parameter across a range",
            Self::Acquire => "Capture data from a detector",
            Self::Move => "Move actuator to a position",
            Self::Wait => "Pause for a duration",
            Self::Loop => "Repeat a sequence N times",
        }
    }

    pub fn color(&self) -> Color32 {
        match self {
            Self::Scan => Color32::from_rgb(100, 149, 237),     // Cornflower blue
            Self::Acquire => Color32::from_rgb(144, 238, 144),  // Light green
            Self::Move => Color32::from_rgb(255, 182, 108),     // Light orange
            Self::Wait => Color32::from_rgb(192, 192, 192),     // Silver
            Self::Loop => Color32::from_rgb(221, 160, 221),     // Plum
        }
    }

    pub fn create_node(&self) -> ExperimentNode {
        match self {
            Self::Scan => ExperimentNode::default_scan(),
            Self::Acquire => ExperimentNode::default_acquire(),
            Self::Move => ExperimentNode::default_move(),
            Self::Wait => ExperimentNode::default_wait(),
            Self::Loop => ExperimentNode::default_loop(),
        }
    }
}

pub struct NodePalette;

impl NodePalette {
    /// Render the palette. Returns Some(NodeType) if a drag started this frame.
    pub fn show(ui: &mut Ui) -> Option<NodeType> {
        let mut dragging = None;

        ui.vertical(|ui| {
            ui.heading("Nodes");
            ui.separator();

            for node_type in NodeType::all() {
                let response = Self::node_button(ui, *node_type);

                // Check if drag started
                if response.drag_started() {
                    dragging = Some(*node_type);
                }
            }
        });

        dragging
    }

    fn node_button(ui: &mut Ui, node_type: NodeType) -> Response {
        let desired_size = Vec2::new(ui.available_width(), 40.0);
        let (rect, response) = ui.allocate_exact_size(desired_size, Sense::drag());

        if ui.is_rect_visible(rect) {
            let visuals = ui.style().interact(&response);
            let rounding = Rounding::same(4.0);

            // Background
            ui.painter().rect_filled(rect, rounding, node_type.color().gamma_multiply(0.3));
            ui.painter().rect_stroke(rect, rounding, visuals.bg_stroke);

            // Color indicator bar on left
            let bar_rect = egui::Rect::from_min_size(
                rect.min,
                Vec2::new(4.0, rect.height())
            );
            ui.painter().rect_filled(bar_rect, rounding, node_type.color());

            // Text
            let text_pos = rect.min + Vec2::new(12.0, 8.0);
            ui.painter().text(
                text_pos,
                egui::Align2::LEFT_TOP,
                node_type.name(),
                egui::FontId::proportional(14.0),
                visuals.text_color(),
            );

            // Description (smaller, dimmer)
            let desc_pos = rect.min + Vec2::new(12.0, 24.0);
            ui.painter().text(
                desc_pos,
                egui::Align2::LEFT_TOP,
                node_type.description(),
                egui::FontId::proportional(10.0),
                visuals.text_color().gamma_multiply(0.7),
            );
        }

        // Show tooltip on hover
        response.on_hover_text(format!("{}: {}", node_type.name(), node_type.description()))
    }
}
```

**mod.rs:**
Add `pub mod node_palette;` and export `NodePalette`, `NodeType`.

Ensure ExperimentNode has `default_scan()`, `default_acquire()`, `default_move()`, `default_wait()`, `default_loop()` constructors in nodes.rs (add if not present from Plan 02-01).
  </action>
  <verify>`cargo check -p daq-egui` compiles with NodePalette widget</verify>
  <done>NodePalette widget shows 5 node types with colors, descriptions, and drag support</done>
</task>

<task type="auto">
  <name>Task 2: Integrate palette and implement drag-to-canvas node creation</name>
  <files>
crates/daq-egui/src/panels/experiment_designer.rs
  </files>
  <action>
Update ExperimentDesignerPanel to show the palette in a sidebar and handle drag-to-canvas:

```rust
use crate::widgets::node_palette::{NodePalette, NodeType};

pub struct ExperimentDesignerPanel {
    snarl: Snarl<ExperimentNode>,
    viewer: ExperimentViewer,
    style: SnarlStyle,
    // Track if a node is being dragged from palette
    dragging_node: Option<NodeType>,
}

impl ExperimentDesignerPanel {
    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // Top toolbar
        ui.horizontal(|ui| {
            ui.label("Experiment Designer");
            ui.separator();
            // Toolbar buttons will be added in later plans (save/load/undo/redo)
        });

        ui.separator();

        // Split into palette (left) and canvas (right)
        egui::SidePanel::left("node_palette_panel")
            .resizable(true)
            .default_width(180.0)
            .min_width(150.0)
            .max_width(300.0)
            .show_inside(ui, |ui| {
                // Check if drag started from palette
                if let Some(node_type) = NodePalette::show(ui) {
                    self.dragging_node = Some(node_type);
                }
            });

        // Main canvas area
        egui::CentralPanel::default().show_inside(ui, |ui| {
            // Handle drop onto canvas
            self.handle_canvas_drop(ui);

            // Render the graph
            egui::Frame::canvas(ui.style()).show(ui, |ui| {
                let id = egui::Id::new("experiment_graph");
                self.snarl.show(&mut self.viewer, &self.style, id, ui);
            });
        });
    }

    fn handle_canvas_drop(&mut self, ui: &mut egui::Ui) {
        // Check if we're dragging and the mouse was released over the canvas
        if let Some(node_type) = self.dragging_node.take() {
            // Use egui's drag-and-drop payload system
            let response = ui.interact(
                ui.available_rect_before_wrap(),
                egui::Id::new("canvas_drop_zone"),
                egui::Sense::hover()
            );

            if response.hovered() {
                // Show drop indicator
                ui.painter().rect_stroke(
                    response.rect,
                    egui::Rounding::same(4.0),
                    egui::Stroke::new(2.0, egui::Color32::LIGHT_BLUE)
                );
            }

            // Check if drag ended (mouse released)
            if !ui.input(|i| i.pointer.any_down()) {
                if let Some(pos) = ui.input(|i| i.pointer.hover_pos()) {
                    if response.rect.contains(pos) {
                        // Create node at drop position
                        let node = node_type.create_node();
                        // Convert screen position to graph position
                        // egui-snarl may handle this internally, check API
                        self.snarl.insert_node(pos, node);
                    }
                }
            } else {
                // Still dragging, keep the state
                self.dragging_node = Some(node_type);
            }
        }
    }
}
```

NOTE: The exact drag-and-drop mechanism depends on egui-snarl's API. Check if egui-snarl has built-in support for inserting nodes at positions. If egui-snarl handles coordinate transforms internally, pass screen coords directly. If not, apply inverse transform.

Alternative approach if egui's dnd is tricky: Use context menu (right-click) to add nodes at cursor position as a fallback UX.
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI, open Experiment Designer
3. Node palette visible on left with 5 node types
4. Drag a node type and drop on canvas - node appears
  </verify>
  <done>Palette sidebar shows node types; dragging from palette and dropping on canvas creates nodes</done>
</task>

<task type="auto">
  <name>Task 3: Implement wire connections with validation</name>
  <files>
crates/daq-egui/src/graph/validation.rs
crates/daq-egui/src/graph/viewer.rs
crates/daq-egui/src/graph/mod.rs
  </files>
  <action>
**validation.rs:**
Create connection validation logic:

```rust
use crate::graph::ExperimentNode;
use egui_snarl::NodeId;

/// Pin types for connection validation
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PinType {
    /// Sequential execution flow (output -> input)
    Flow,
    /// Loop body connection (special)
    LoopBody,
}

/// Get the type of an output pin for a node
pub fn output_pin_type(node: &ExperimentNode, output_idx: usize) -> PinType {
    match node {
        ExperimentNode::Loop { .. } => {
            if output_idx == 0 { PinType::Flow }     // "Next" output
            else { PinType::LoopBody }               // "Body" output
        }
        _ => PinType::Flow,
    }
}

/// Get the type of an input pin for a node
pub fn input_pin_type(node: &ExperimentNode, _input_idx: usize) -> PinType {
    // For now, all inputs accept flow connections
    // Loop body is handled by output_pin_type
    PinType::Flow
}

/// Validate a proposed connection
pub fn validate_connection(
    from_node: &ExperimentNode,
    from_output: usize,
    to_node: &ExperimentNode,
    to_input: usize,
) -> Result<(), String> {
    let out_type = output_pin_type(from_node, from_output);
    let in_type = input_pin_type(to_node, to_input);

    // Flow pins can connect to flow pins
    // LoopBody can connect to flow (it's still a flow, just semantically different)
    match (out_type, in_type) {
        (PinType::Flow, PinType::Flow) => Ok(()),
        (PinType::LoopBody, PinType::Flow) => Ok(()),
        _ => Err(format!(
            "Cannot connect {:?} output to {:?} input",
            out_type, in_type
        )),
    }
}

/// Check for cycles (simple DFS, can be upgraded to petgraph later)
pub fn would_create_cycle(
    _from_node_id: NodeId,
    _to_node_id: NodeId,
    // Would need snarl reference to check existing connections
) -> bool {
    // TODO: Implement cycle detection if needed
    // For now, allow all connections (sequential flow doesn't typically cycle)
    false
}
```

**viewer.rs:**
Update ExperimentViewer to use validation in connect():

```rust
use crate::graph::validation::{validate_connection, PinType, output_pin_type, input_pin_type};

pub struct ExperimentViewer {
    /// Last validation error (shown as toast/status)
    pub last_error: Option<String>,
}

impl SnarlViewer<ExperimentNode> for ExperimentViewer {
    // ... existing methods ...

    fn connect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ExperimentNode>) {
        // Get node data for validation
        let from_node = snarl.get_node(from.id.node);
        let to_node = snarl.get_node(to.id.node);

        if let (Some(from_node), Some(to_node)) = (from_node, to_node) {
            match validate_connection(from_node, from.id.output, to_node, to.id.input) {
                Ok(()) => {
                    // Valid connection, create it
                    snarl.connect(from.id.node, from.id.output, to.id.node, to.id.input);
                    self.last_error = None;
                }
                Err(msg) => {
                    // Invalid, show error
                    self.last_error = Some(msg);
                }
            }
        }
    }

    fn disconnect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ExperimentNode>) {
        snarl.disconnect(from.id.node, from.id.output, to.id.node, to.id.input);
    }

    // Optional: Show pin type visually
    fn show_output(&mut self, pin: &OutPin, ui: &mut Ui, scale: f32,
                   snarl: &mut Snarl<ExperimentNode>) -> PinInfo {
        if let Some(node) = snarl.get_node(pin.id.node) {
            let pin_type = output_pin_type(node, pin.id.output);
            match pin_type {
                PinType::Flow => ui.label(">"),
                PinType::LoopBody => ui.label("L"),  // Loop body indicator
            };
        }
        PinInfo::default()
    }
}
```

**mod.rs:**
Add `pub mod validation;` and export validation types if needed externally.

NOTE: Check egui-snarl 0.9 API for exact method signatures of connect/disconnect. The trait may have different parameter types. Adapt code accordingly.
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI, add two nodes to canvas
3. Drag from output pin to input pin - wire drawn and connected
4. Attempt invalid connection (if any rules exist) - connection rejected
  </verify>
  <done>Wires can be drawn between nodes; validation prevents invalid connections; validation errors stored in viewer</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cargo build -p daq-egui
   cargo clippy -p daq-egui -- -D warnings
   ```

2. **Functional verification:**
   - Open Experiment Designer panel
   - Node palette visible on left side with 5 node types
   - Drag "Scan" node to canvas - node appears
   - Drag "Acquire" node to canvas - second node appears
   - Drag wire from Scan output to Acquire input - connection forms
   - Nodes can be repositioned by dragging

3. **Validation verification:**
   - Attempt to connect output to output (if possible) - should be rejected or not allowed
   - Check that validation error is captured (may need log output)
</verification>

<success_criteria>
- NodePalette widget shows 5 draggable node types with colors and descriptions
- Dragging from palette and dropping on canvas creates nodes at drop position
- Wires can be drawn between output and input pins
- Connection validation runs on connect attempt
- All code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-node-graph-editor-core/02-02-SUMMARY.md`
</output>
