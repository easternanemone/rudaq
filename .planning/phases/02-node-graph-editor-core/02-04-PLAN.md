---
phase: 02-node-graph-editor-core
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - crates/daq-egui/src/graph/serialization.rs
  - crates/daq-egui/src/graph/mod.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: false

must_haves:
  truths:
    - "User can save the current graph to a JSON file via File menu or toolbar"
    - "User can load a previously saved graph from a JSON file"
    - "Invalid connections show red visual indicator on the affected node"
    - "User can select multiple nodes and group them into a collapsible subgraph"
  artifacts:
    - path: "crates/daq-egui/src/graph/serialization.rs"
      provides: "JSON save/load functions"
      contains: "save_graph"
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Save/Load toolbar buttons and file dialogs"
      contains: "save_graph"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/graph/serialization.rs"
      via: "save_graph/load_graph function calls"
      pattern: "serialization::"
---

<objective>
Implement file persistence (save/load JSON) and visual validation error display. Optionally implement subgraph grouping if feasible.

Purpose: File persistence allows users to save work and continue later, or share experiment designs. Visual error display helps users understand when something is wrong with their graph.

Output: Users can save/load graphs to JSON files and see validation errors visually. Subgraph grouping if implementation is straightforward.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-node-graph-editor-core/02-RESEARCH.md
@.planning/phases/02-node-graph-editor-core/02-01-SUMMARY.md
@.planning/phases/02-node-graph-editor-core/02-02-SUMMARY.md
@.planning/phases/02-node-graph-editor-core/02-03-SUMMARY.md

# Current graph module:
@crates/daq-egui/src/graph/mod.rs
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/panels/experiment_designer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JSON serialization for graph save/load</name>
  <files>
crates/daq-egui/src/graph/serialization.rs
crates/daq-egui/src/graph/mod.rs
  </files>
  <action>
Create serialization module for saving and loading experiment graphs:

**serialization.rs:**

```rust
use std::path::Path;
use serde::{Deserialize, Serialize};
use egui_snarl::Snarl;
use crate::graph::ExperimentNode;

/// Complete graph state for serialization
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GraphFile {
    /// Version for future compatibility
    pub version: u32,
    /// Optional metadata
    pub metadata: GraphMetadata,
    /// The actual graph data (egui-snarl's Snarl is serde-compatible)
    pub graph: Snarl<ExperimentNode>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct GraphMetadata {
    pub name: String,
    pub description: String,
    pub created: Option<String>,      // ISO 8601 timestamp
    pub modified: Option<String>,     // ISO 8601 timestamp
    pub author: Option<String>,
}

impl GraphFile {
    pub const CURRENT_VERSION: u32 = 1;

    pub fn new(graph: Snarl<ExperimentNode>) -> Self {
        Self {
            version: Self::CURRENT_VERSION,
            metadata: GraphMetadata::default(),
            graph,
        }
    }

    pub fn with_metadata(mut self, metadata: GraphMetadata) -> Self {
        self.metadata = metadata;
        self
    }
}

/// Save graph to JSON file
pub fn save_graph(path: &Path, file: &GraphFile) -> Result<(), String> {
    let json = serde_json::to_string_pretty(file)
        .map_err(|e| format!("Failed to serialize graph: {}", e))?;

    std::fs::write(path, json)
        .map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(())
}

/// Load graph from JSON file
pub fn load_graph(path: &Path) -> Result<GraphFile, String> {
    let json = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let file: GraphFile = serde_json::from_str(&json)
        .map_err(|e| format!("Failed to parse graph file: {}", e))?;

    // Version check for future compatibility
    if file.version > GraphFile::CURRENT_VERSION {
        return Err(format!(
            "Graph file version {} is newer than supported version {}",
            file.version,
            GraphFile::CURRENT_VERSION
        ));
    }

    Ok(file)
}

/// File extension for experiment graphs
pub const GRAPH_FILE_EXTENSION: &str = "expgraph";
pub const GRAPH_FILE_FILTER: &str = "Experiment Graph (*.expgraph)";
```

**mod.rs:**
Add `pub mod serialization;` and export `GraphFile`, `GraphMetadata`, `save_graph`, `load_graph`.
  </action>
  <verify>`cargo check -p daq-egui` compiles with serialization module</verify>
  <done>GraphFile struct serializes graph + metadata; save_graph/load_graph functions work with JSON</done>
</task>

<task type="auto">
  <name>Task 2: Add Save/Load UI with file dialogs</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Update ExperimentDesignerPanel to add Save/Load functionality:

```rust
use crate::graph::serialization::{GraphFile, GraphMetadata, save_graph, load_graph, GRAPH_FILE_EXTENSION};

pub struct ExperimentDesignerPanel {
    // ... existing fields ...

    /// Current file path (None if unsaved)
    current_file: Option<std::path::PathBuf>,
    /// Graph metadata
    metadata: GraphMetadata,
    /// Status message for save/load feedback
    status_message: Option<(String, std::time::Instant)>,
}

impl ExperimentDesignerPanel {
    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // Handle keyboard shortcuts
        self.handle_keyboard(ui);

        // Top toolbar
        ui.horizontal(|ui| {
            ui.label("Experiment Designer");
            ui.separator();

            // File operations
            if ui.button("New").clicked() {
                self.new_graph();
            }

            if ui.button("Open...").clicked() {
                self.open_file_dialog();
            }

            if ui.button("Save").clicked() {
                self.save_current();
            }

            if ui.button("Save As...").clicked() {
                self.save_file_dialog();
            }

            ui.separator();

            // Undo/Redo (existing)
            let can_undo = self.history.can_undo();
            if ui.add_enabled(can_undo, egui::Button::new("Undo")).clicked() {
                self.undo();
            }
            let can_redo = self.history.can_redo();
            if ui.add_enabled(can_redo, egui::Button::new("Redo")).clicked() {
                self.redo();
            }

            ui.separator();

            // Show current file name
            if let Some(path) = &self.current_file {
                if let Some(name) = path.file_name() {
                    ui.label(format!("File: {}", name.to_string_lossy()));
                }
            } else {
                ui.label("Unsaved");
            }

            // Show status message (auto-fades)
            if let Some((msg, time)) = &self.status_message {
                if time.elapsed().as_secs() < 3 {
                    ui.separator();
                    ui.label(msg);
                } else {
                    self.status_message = None;
                }
            }
        });

        // ... rest of UI (palette, canvas, inspector) ...
    }

    fn new_graph(&mut self) {
        self.snarl = Snarl::new();
        self.history = Record::new();
        self.current_file = None;
        self.metadata = GraphMetadata::default();
        self.selected_node = None;
        self.set_status("New graph created");
    }

    fn open_file_dialog(&mut self) {
        // Use rfd (rusty file dialogs) for native file picker
        // Add rfd to dependencies if not present
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Experiment Graph", &[GRAPH_FILE_EXTENSION])
            .add_filter("All Files", &["*"])
            .pick_file()
        {
            self.load_from_path(&path);
        }
    }

    fn load_from_path(&mut self, path: &std::path::Path) {
        match load_graph(path) {
            Ok(file) => {
                self.snarl = file.graph;
                self.metadata = file.metadata;
                self.current_file = Some(path.to_path_buf());
                self.history = Record::new();  // Clear history for loaded file
                self.selected_node = None;
                self.set_status(format!("Loaded: {}", path.display()));
            }
            Err(e) => {
                self.set_status(format!("Error: {}", e));
            }
        }
    }

    fn save_current(&mut self) {
        if let Some(path) = self.current_file.clone() {
            self.save_to_path(&path);
        } else {
            self.save_file_dialog();
        }
    }

    fn save_file_dialog(&mut self) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Experiment Graph", &[GRAPH_FILE_EXTENSION])
            .set_file_name("experiment.expgraph")
            .save_file()
        {
            self.save_to_path(&path);
        }
    }

    fn save_to_path(&mut self, path: &std::path::Path) {
        // Update modification timestamp
        self.metadata.modified = Some(chrono::Utc::now().to_rfc3339());
        if self.metadata.created.is_none() {
            self.metadata.created = self.metadata.modified.clone();
        }

        let file = GraphFile::new(self.snarl.clone())
            .with_metadata(self.metadata.clone());

        match save_graph(path, &file) {
            Ok(()) => {
                self.current_file = Some(path.to_path_buf());
                self.set_status(format!("Saved: {}", path.display()));
            }
            Err(e) => {
                self.set_status(format!("Error: {}", e));
            }
        }
    }

    fn set_status(&mut self, msg: impl Into<String>) {
        self.status_message = Some((msg.into(), std::time::Instant::now()));
    }

    // Add Ctrl+S/Ctrl+O to handle_keyboard
    fn handle_keyboard(&mut self, ui: &mut egui::Ui) {
        // Ctrl+S = Save
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::S)) {
            self.save_current();
        }

        // Ctrl+O = Open
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::O)) {
            self.open_file_dialog();
        }

        // ... existing undo/redo shortcuts ...
    }
}
```

Add `rfd` and `chrono` dependencies to Cargo.toml if not present:
```toml
rfd = "0.14"      # Rusty file dialogs
chrono = "0.4"    # Timestamps
```

NOTE: If `rfd` has issues (requires async-std or other deps), can use a simpler approach:
- Show a text input field for path
- Or use egui's built-in file drag-drop support
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI, add some nodes, click "Save As...", save to file
3. Click "New", then "Open...", load the saved file
4. Verify nodes restored correctly
  </verify>
  <done>Save/Load buttons in toolbar; file dialogs work; Ctrl+S/Ctrl+O shortcuts; status messages show save/load feedback</done>
</task>

<task type="auto">
  <name>Task 3: Add visual validation error display</name>
  <files>
crates/daq-egui/src/graph/viewer.rs
crates/daq-egui/src/panels/experiment_designer.rs
  </files>
  <action>
Update the viewer to show validation errors visually on nodes:

**viewer.rs:**
Extend ExperimentViewer to track and display validation errors:

```rust
use std::collections::HashMap;
use egui_snarl::NodeId;

pub struct ExperimentViewer {
    pub last_error: Option<String>,
    /// Per-node validation errors
    pub node_errors: HashMap<NodeId, String>,
}

impl ExperimentViewer {
    pub fn new() -> Self {
        Self {
            last_error: None,
            node_errors: HashMap::new(),
        }
    }

    pub fn set_node_error(&mut self, node_id: NodeId, error: String) {
        self.node_errors.insert(node_id, error);
    }

    pub fn clear_node_error(&mut self, node_id: NodeId) {
        self.node_errors.remove(&node_id);
    }

    pub fn clear_all_errors(&mut self) {
        self.node_errors.clear();
        self.last_error = None;
    }
}

impl SnarlViewer<ExperimentNode> for ExperimentViewer {
    // ... existing methods ...

    // If egui-snarl provides a way to customize node frame/border:
    fn node_frame(&self, node: &NodeId, _snarl: &Snarl<ExperimentNode>) -> egui::Frame {
        let mut frame = egui::Frame::default();

        if self.node_errors.contains_key(node) {
            // Red border for nodes with errors
            frame = frame.stroke(egui::Stroke::new(2.0, egui::Color32::RED));
        }

        frame
    }

    // Show error in node body if egui-snarl allows body customization
    fn show_body(&mut self, node_id: NodeId, _inputs: &[InPin], _outputs: &[OutPin],
                 ui: &mut Ui, _scale: f32, snarl: &mut Snarl<ExperimentNode>) {
        if let Some(error) = self.node_errors.get(&node_id) {
            ui.colored_label(egui::Color32::RED, error);
        }

        // ... node-specific body content ...
    }
}
```

**experiment_designer.rs:**
Add validation that runs periodically or on specific triggers:

```rust
impl ExperimentDesignerPanel {
    /// Validate the entire graph and update error display
    fn validate_graph(&mut self) {
        self.viewer.clear_all_errors();

        // Check each node for issues
        for (node_id, node) in self.snarl.nodes() {
            if let Some(error) = self.validate_node(node_id, node) {
                self.viewer.set_node_error(node_id, error);
            }
        }
    }

    fn validate_node(&self, _node_id: NodeId, node: &ExperimentNode) -> Option<String> {
        match node {
            ExperimentNode::Scan { actuator, points, .. } => {
                if actuator.is_empty() {
                    return Some("Actuator not set".to_string());
                }
                if *points == 0 {
                    return Some("Points must be > 0".to_string());
                }
            }
            ExperimentNode::Acquire { detector, .. } => {
                if detector.is_empty() {
                    return Some("Detector not set".to_string());
                }
            }
            ExperimentNode::Move { device, .. } => {
                if device.is_empty() {
                    return Some("Device not set".to_string());
                }
            }
            _ => {}
        }
        None
    }
}
```

NOTE: The exact API for customizing node appearance depends on egui-snarl 0.9. Check:
- Does `SnarlViewer` have a `node_frame()` or `show_header()` method?
- Can we hook into the node rendering to add a border?

If not available, show errors in a separate panel or via tooltips on hover.
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Add a Scan node, leave actuator empty
3. Trigger validation (may need a "Validate" button temporarily)
4. See red border or error message on the invalid node
  </verify>
  <done>Nodes with validation errors show visual indicator (red border or error text); validation checks required fields</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete node graph editor with:
- Node palette for drag-and-drop creation
- Wire connections between nodes
- Property inspector for editing node parameters
- Undo/redo with Ctrl+Z/Ctrl+Y
- Save/Load to JSON files
- Validation error display
  </what-built>
  <how-to-verify>
1. Launch the GUI with mock daemon
2. Open "Experiment Designer" panel

**Test node creation:**
3. Drag "Scan" from palette to canvas - node should appear
4. Drag "Acquire" from palette - second node should appear
5. Drag wire from Scan output to Acquire input - wire should connect

**Test property editing:**
6. Click on Scan node (or select somehow)
7. In right panel, change "Start" value from 0 to 10
8. Verify the change persists

**Test undo/redo:**
9. Press Ctrl+Z - last change should undo
10. Press Ctrl+Y - change should redo
11. Delete a node, Ctrl+Z to restore it

**Test save/load:**
12. Click "Save As...", save to test.expgraph
13. Click "New" to clear graph
14. Click "Open...", load test.expgraph
15. Verify nodes restored correctly

**Test validation:**
16. Add a Scan node with empty actuator field
17. Look for red border or error indicator on node

Note any issues or unexpected behavior for the summary.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete (including human verification):

1. **Build verification:**
   ```bash
   cargo build -p daq-egui
   cargo clippy -p daq-egui -- -D warnings
   ```

2. **Serialization verification:**
   - Save graph, check JSON file is valid and human-readable
   - Load graph, verify structure matches original

3. **Validation verification:**
   - Incomplete nodes show errors
   - Valid nodes show no errors

4. **Complete workflow:**
   - Create graph with multiple nodes
   - Connect them appropriately
   - Save to file
   - Clear and reload
   - Verify full restoration
</verification>

<success_criteria>
- GraphFile struct serializes graph + metadata to JSON
- Save/Load buttons work with native file dialogs
- Ctrl+S saves, Ctrl+O opens
- Status messages confirm save/load operations
- Validation errors display visually on nodes
- Complete editing workflow verified by human tester
</success_criteria>

<output>
After completion, create `.planning/phases/02-node-graph-editor-core/02-04-SUMMARY.md`
</output>
