---
phase: 02-node-graph-editor-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/daq-egui/src/widgets/property_inspector.rs
  - crates/daq-egui/src/widgets/mod.rs
  - crates/daq-egui/src/graph/commands.rs
  - crates/daq-egui/src/graph/mod.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true

must_haves:
  truths:
    - "User can select a node on the canvas and see its properties in an inspector panel"
    - "User can edit node parameters (actuator, start, stop, points, etc.) in the inspector"
    - "User can press Ctrl+Z to undo the last edit"
    - "User can press Ctrl+Y or Ctrl+Shift+Z to redo an undone edit"
  artifacts:
    - path: "crates/daq-egui/src/widgets/property_inspector.rs"
      provides: "Property editing panel for selected node"
      contains: "PropertyInspector"
    - path: "crates/daq-egui/src/graph/commands.rs"
      provides: "Edit implementations for undo/redo"
      contains: "impl Edit"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/widgets/property_inspector.rs"
      via: "PropertyInspector rendering for selected node"
      pattern: "PropertyInspector"
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/graph/commands.rs"
      via: "history.edit() calls for tracked modifications"
      pattern: "history\\.edit"
---

<objective>
Implement property editing for selected nodes and undo/redo functionality using the command pattern.

Purpose: Property editing allows users to configure node parameters (scan ranges, wait durations, device selections). Undo/redo provides essential editing safety - users can experiment without fear of losing work.

Output: Users can select nodes, edit their properties in an inspector panel, and undo/redo changes with keyboard shortcuts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-node-graph-editor-core/02-RESEARCH.md
@.planning/phases/02-node-graph-editor-core/02-01-SUMMARY.md

# Graph module from Plan 02-01:
@crates/daq-egui/src/graph/mod.rs
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/graph/viewer.rs
@crates/daq-egui/src/panels/experiment_designer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PropertyInspector widget for node editing</name>
  <files>
crates/daq-egui/src/widgets/property_inspector.rs
crates/daq-egui/src/widgets/mod.rs
  </files>
  <action>
Create the PropertyInspector widget that shows editable properties for the selected node:

**property_inspector.rs:**

```rust
use egui::Ui;
use crate::graph::ExperimentNode;

/// Result of property editing - returns modified node if changed
pub struct PropertyInspector;

impl PropertyInspector {
    /// Show properties for a node. Returns Some(modified_node) if user made changes.
    pub fn show(ui: &mut Ui, node: &ExperimentNode) -> Option<ExperimentNode> {
        let mut modified = node.clone();
        let mut changed = false;

        ui.vertical(|ui| {
            ui.heading(node.node_name());
            ui.separator();

            match &mut modified {
                ExperimentNode::Scan { actuator, start, stop, points } => {
                    changed |= Self::text_field(ui, "Actuator", actuator);
                    changed |= Self::float_field(ui, "Start", start);
                    changed |= Self::float_field(ui, "Stop", stop);
                    changed |= Self::u32_field(ui, "Points", points);
                }
                ExperimentNode::Acquire { detector, duration_ms } => {
                    changed |= Self::text_field(ui, "Detector", detector);
                    changed |= Self::float_field(ui, "Duration (ms)", duration_ms);
                }
                ExperimentNode::Move { device, position } => {
                    changed |= Self::text_field(ui, "Device", device);
                    changed |= Self::float_field(ui, "Position", position);
                }
                ExperimentNode::Wait { duration_ms } => {
                    changed |= Self::float_field(ui, "Duration (ms)", duration_ms);
                }
                ExperimentNode::Loop { iterations } => {
                    changed |= Self::u32_field(ui, "Iterations", iterations);
                }
            }
        });

        if changed { Some(modified) } else { None }
    }

    fn text_field(ui: &mut Ui, label: &str, value: &mut String) -> bool {
        ui.horizontal(|ui| {
            ui.label(label);
            ui.text_edit_singleline(value).changed()
        }).inner
    }

    fn float_field(ui: &mut Ui, label: &str, value: &mut f64) -> bool {
        ui.horizontal(|ui| {
            ui.label(label);
            // Use DragValue for numeric input with drag support
            ui.add(egui::DragValue::new(value).speed(0.1)).changed()
        }).inner
    }

    fn u32_field(ui: &mut Ui, label: &str, value: &mut u32) -> bool {
        ui.horizontal(|ui| {
            ui.label(label);
            let mut v = *value as i32;
            let changed = ui.add(
                egui::DragValue::new(&mut v)
                    .speed(1)
                    .range(1..=10000)
            ).changed();
            if changed {
                *value = v.max(1) as u32;
            }
            changed
        }).inner
    }

    /// Show placeholder when no node selected
    pub fn show_empty(ui: &mut Ui) {
        ui.vertical_centered(|ui| {
            ui.add_space(20.0);
            ui.label("Select a node to edit its properties");
        });
    }
}
```

**mod.rs:**
Add `pub mod property_inspector;` and export `PropertyInspector`.
  </action>
  <verify>`cargo check -p daq-egui` compiles with PropertyInspector widget</verify>
  <done>PropertyInspector shows editable fields for each node type; returns modified node on change</done>
</task>

<task type="auto">
  <name>Task 2: Implement command pattern with undo crate</name>
  <files>
crates/daq-egui/src/graph/commands.rs
crates/daq-egui/src/graph/mod.rs
  </files>
  <action>
Create Edit implementations for graph operations using the `undo` crate:

**commands.rs:**

```rust
use undo::{Edit, Merged};
use egui_snarl::{Snarl, NodeId};
use crate::graph::ExperimentNode;

/// The target type for all graph edits
pub type GraphTarget = Snarl<ExperimentNode>;

/// Add a node to the graph
pub struct AddNode {
    pub node: ExperimentNode,
    pub position: egui::Pos2,
    /// Set after edit() to allow undo
    pub node_id: Option<NodeId>,
}

impl Edit for AddNode {
    type Target = GraphTarget;
    type Output = ();

    fn edit(&mut self, target: &mut Self::Target) -> Self::Output {
        // Insert node and store ID for undo
        let id = target.insert_node(self.position, self.node.clone());
        self.node_id = Some(id);
    }

    fn undo(&mut self, target: &mut Self::Target) -> Self::Output {
        if let Some(id) = self.node_id {
            target.remove_node(id);
        }
    }
}

/// Remove a node from the graph
pub struct RemoveNode {
    pub node_id: NodeId,
    /// Stored for undo
    pub node: Option<ExperimentNode>,
    pub position: Option<egui::Pos2>,
}

impl Edit for RemoveNode {
    type Target = GraphTarget;
    type Output = ();

    fn edit(&mut self, target: &mut Self::Target) -> Self::Output {
        // Store node data for undo
        if let Some(node) = target.get_node(self.node_id) {
            self.node = Some(node.clone());
        }
        // egui-snarl may store position differently, check API
        // For now, use a default position for undo
        self.position = Some(egui::Pos2::new(100.0, 100.0));
        target.remove_node(self.node_id);
    }

    fn undo(&mut self, target: &mut Self::Target) -> Self::Output {
        if let (Some(node), Some(pos)) = (self.node.take(), self.position) {
            target.insert_node(pos, node);
            // Note: node ID may change after re-insert
        }
    }
}

/// Modify a node's properties
pub struct ModifyNode {
    pub node_id: NodeId,
    pub old_data: ExperimentNode,
    pub new_data: ExperimentNode,
}

impl Edit for ModifyNode {
    type Target = GraphTarget;
    type Output = ();

    fn edit(&mut self, target: &mut Self::Target) -> Self::Output {
        if let Some(node) = target.get_node_mut(self.node_id) {
            *node = self.new_data.clone();
        }
    }

    fn undo(&mut self, target: &mut Self::Target) -> Self::Output {
        if let Some(node) = target.get_node_mut(self.node_id) {
            *node = self.old_data.clone();
        }
    }

    fn merge(&mut self, other: Self) -> Merged<Self>
    where
        Self: Sized,
    {
        // Merge consecutive modifications to the same node
        if self.node_id == other.node_id {
            self.new_data = other.new_data;
            Merged::Yes
        } else {
            Merged::No
        }
    }
}

/// Connect two nodes
pub struct ConnectNodes {
    pub from_node: NodeId,
    pub from_output: usize,
    pub to_node: NodeId,
    pub to_input: usize,
}

impl Edit for ConnectNodes {
    type Target = GraphTarget;
    type Output = ();

    fn edit(&mut self, target: &mut Self::Target) -> Self::Output {
        target.connect(self.from_node, self.from_output, self.to_node, self.to_input);
    }

    fn undo(&mut self, target: &mut Self::Target) -> Self::Output {
        target.disconnect(self.from_node, self.from_output, self.to_node, self.to_input);
    }
}

/// Disconnect two nodes
pub struct DisconnectNodes {
    pub from_node: NodeId,
    pub from_output: usize,
    pub to_node: NodeId,
    pub to_input: usize,
}

impl Edit for DisconnectNodes {
    type Target = GraphTarget;
    type Output = ();

    fn edit(&mut self, target: &mut Self::Target) -> Self::Output {
        target.disconnect(self.from_node, self.from_output, self.to_node, self.to_input);
    }

    fn undo(&mut self, target: &mut Self::Target) -> Self::Output {
        target.connect(self.from_node, self.from_output, self.to_node, self.to_input);
    }
}
```

**mod.rs:**
Add `pub mod commands;` and export command types.

NOTE: Check egui-snarl 0.9 API for:
- How `insert_node` returns the NodeId
- How to get/set node positions (may be in separate layout structure)
- Exact method signatures for connect/disconnect

Adapt code to match actual API.
  </action>
  <verify>`cargo check -p daq-egui` compiles with command implementations</verify>
  <done>Edit implementations exist for AddNode, RemoveNode, ModifyNode, ConnectNodes, DisconnectNodes</done>
</task>

<task type="auto">
  <name>Task 3: Integrate property inspector and undo/redo into panel</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Update ExperimentDesignerPanel to:
1. Show property inspector in a right sidebar when a node is selected
2. Track undo/redo history using `undo::Record`
3. Handle Ctrl+Z and Ctrl+Y keyboard shortcuts

```rust
use undo::Record;
use crate::graph::commands::{GraphTarget, AddNode, ModifyNode, ConnectNodes};
use crate::widgets::property_inspector::PropertyInspector;
use egui_snarl::NodeId;

pub struct ExperimentDesignerPanel {
    snarl: Snarl<ExperimentNode>,
    viewer: ExperimentViewer,
    style: SnarlStyle,
    dragging_node: Option<NodeType>,
    // NEW: Undo/redo history
    history: Record<GraphTarget>,
    // NEW: Selected node for property editing
    selected_node: Option<NodeId>,
}

impl Default for ExperimentDesignerPanel {
    fn default() -> Self {
        Self {
            snarl: Snarl::new(),
            viewer: ExperimentViewer::new(),
            style: SnarlStyle::default(),
            dragging_node: None,
            history: Record::new(),
            selected_node: None,
        }
    }
}

impl ExperimentDesignerPanel {
    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // Handle keyboard shortcuts FIRST (before any UI that might consume keys)
        self.handle_keyboard(ui);

        // Top toolbar with undo/redo buttons
        ui.horizontal(|ui| {
            ui.label("Experiment Designer");
            ui.separator();

            // Undo button
            let can_undo = self.history.can_undo();
            if ui.add_enabled(can_undo, egui::Button::new("Undo")).clicked() {
                self.undo();
            }

            // Redo button
            let can_redo = self.history.can_redo();
            if ui.add_enabled(can_redo, egui::Button::new("Redo")).clicked() {
                self.redo();
            }

            ui.separator();

            // Show undo/redo count
            ui.label(format!("History: {} | {}", self.history.len(), self.history.limit()));
        });

        ui.separator();

        // Three-panel layout: Palette | Canvas | Inspector
        egui::SidePanel::left("node_palette_panel")
            .resizable(true)
            .default_width(180.0)
            .show_inside(ui, |ui| {
                if let Some(node_type) = NodePalette::show(ui) {
                    self.dragging_node = Some(node_type);
                }
            });

        egui::SidePanel::right("property_inspector_panel")
            .resizable(true)
            .default_width(200.0)
            .min_width(150.0)
            .max_width(400.0)
            .show_inside(ui, |ui| {
                self.show_property_inspector(ui);
            });

        egui::CentralPanel::default().show_inside(ui, |ui| {
            self.handle_canvas_drop(ui);

            egui::Frame::canvas(ui.style()).show(ui, |ui| {
                let id = egui::Id::new("experiment_graph");

                // Before showing graph, capture selected state
                // egui-snarl may provide selection via viewer or response
                self.snarl.show(&mut self.viewer, &self.style, id, ui);

                // Check for node selection (egui-snarl may expose this differently)
                // May need to implement selection in viewer or via egui response
            });
        });
    }

    fn show_property_inspector(&mut self, ui: &mut egui::Ui) {
        ui.heading("Properties");
        ui.separator();

        if let Some(node_id) = self.selected_node {
            if let Some(node) = self.snarl.get_node(node_id) {
                // Show inspector and check for modifications
                if let Some(modified_node) = PropertyInspector::show(ui, node) {
                    // Create undo-tracked modification
                    let old_data = node.clone();
                    self.history.edit(&mut self.snarl, ModifyNode {
                        node_id,
                        old_data,
                        new_data: modified_node,
                    });
                }
            } else {
                // Node was deleted, clear selection
                self.selected_node = None;
                PropertyInspector::show_empty(ui);
            }
        } else {
            PropertyInspector::show_empty(ui);
        }
    }

    fn handle_keyboard(&mut self, ui: &mut egui::Ui) {
        // Undo: Ctrl+Z (Cmd+Z on Mac)
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::Z)) {
            if ui.input(|i| i.modifiers.shift) {
                // Ctrl+Shift+Z = Redo
                self.redo();
            } else {
                // Ctrl+Z = Undo
                self.undo();
            }
        }

        // Redo: Ctrl+Y
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::Y)) {
            self.redo();
        }

        // Delete: Delete or Backspace to remove selected node
        if ui.input(|i| i.key_pressed(egui::Key::Delete) || i.key_pressed(egui::Key::Backspace)) {
            if let Some(node_id) = self.selected_node.take() {
                // TODO: Use RemoveNode command once node positions are tracked
                self.snarl.remove_node(node_id);
            }
        }
    }

    fn undo(&mut self) {
        self.history.undo(&mut self.snarl);
    }

    fn redo(&mut self) {
        self.history.redo(&mut self.snarl);
    }

    // Update handle_canvas_drop to use undo-tracked AddNode
    fn handle_canvas_drop(&mut self, ui: &mut egui::Ui) {
        if let Some(node_type) = self.dragging_node.take() {
            let response = ui.interact(
                ui.available_rect_before_wrap(),
                egui::Id::new("canvas_drop_zone"),
                egui::Sense::hover()
            );

            if !ui.input(|i| i.pointer.any_down()) {
                if let Some(pos) = ui.input(|i| i.pointer.hover_pos()) {
                    if response.rect.contains(pos) {
                        // Create node with undo tracking
                        self.history.edit(&mut self.snarl, AddNode {
                            node: node_type.create_node(),
                            position: pos,
                            node_id: None,
                        });
                    }
                }
            } else {
                self.dragging_node = Some(node_type);
            }
        }
    }
}
```

NOTE: Node selection is tricky with egui-snarl. Check if:
- egui-snarl provides a `selected_node()` method or callback
- Selection needs to be implemented via click detection in the viewer
- The SnarlViewer trait has selection hooks

May need to implement selection detection by checking egui responses or adding a click handler in the viewer. A fallback is to use context menu on right-click to select nodes.
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI, open Experiment Designer
3. Add a node, see it in canvas
4. Press Ctrl+Z - node disappears (undo)
5. Press Ctrl+Y - node reappears (redo)
6. (If selection works) Click node, see properties in right panel, edit value, see change in node
  </verify>
  <done>Property inspector shows selected node properties; undo/redo works via Ctrl+Z/Ctrl+Y; Undo/Redo toolbar buttons functional</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cargo build -p daq-egui
   cargo clippy -p daq-egui -- -D warnings
   ```

2. **Undo/redo verification:**
   - Add node to canvas, press Ctrl+Z - node removed
   - Press Ctrl+Y - node restored
   - Add multiple nodes, undo multiple times
   - Redo works correctly

3. **Property inspector verification:**
   - Select node (click or however selection works)
   - Property panel shows node-specific fields
   - Edit a value, verify change persists
   - Undo property change, verify old value restored

4. **Keyboard shortcuts:**
   - Ctrl+Z undoes last action
   - Ctrl+Y redoes undone action
   - Ctrl+Shift+Z also redoes (alternative)
</verification>

<success_criteria>
- PropertyInspector widget shows editable fields for each node type
- Edit commands (AddNode, ModifyNode, etc.) implement undo crate Edit trait
- Undo/redo history tracks all graph modifications
- Ctrl+Z and Ctrl+Y keyboard shortcuts work
- Toolbar shows Undo/Redo buttons with enabled/disabled state
- Property edits are tracked in undo history
</success_criteria>

<output>
After completion, create `.planning/phases/02-node-graph-editor-core/02-03-SUMMARY.md`
</output>
