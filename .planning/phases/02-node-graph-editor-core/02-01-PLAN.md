---
phase: 02-node-graph-editor-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/Cargo.toml
  - crates/daq-egui/src/graph/mod.rs
  - crates/daq-egui/src/graph/nodes.rs
  - crates/daq-egui/src/graph/viewer.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
  - crates/daq-egui/src/panels/mod.rs
  - crates/daq-egui/src/app.rs
autonomous: true

must_haves:
  truths:
    - "User can see an empty node graph canvas in the Experiment Designer panel"
    - "User can pan and zoom the canvas"
    - "Application compiles and runs with egui-snarl integrated"
  artifacts:
    - path: "crates/daq-egui/Cargo.toml"
      provides: "egui-snarl and undo dependencies"
      contains: "egui-snarl"
    - path: "crates/daq-egui/src/graph/mod.rs"
      provides: "Graph module exports"
      min_lines: 5
    - path: "crates/daq-egui/src/graph/nodes.rs"
      provides: "ExperimentNode enum with serde"
      contains: "enum ExperimentNode"
    - path: "crates/daq-egui/src/graph/viewer.rs"
      provides: "SnarlViewer trait implementation"
      contains: "impl SnarlViewer"
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "ExperimentDesignerPanel with graph canvas"
      contains: "ExperimentDesignerPanel"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/graph/viewer.rs"
      via: "snarl.show() call"
      pattern: "snarl\\.show"
    - from: "crates/daq-egui/src/app.rs"
      to: "crates/daq-egui/src/panels/experiment_designer.rs"
      via: "Panel::ExperimentDesigner variant"
      pattern: "ExperimentDesigner"
---

<objective>
Establish the graph module foundation with egui-snarl integration, creating the basic infrastructure for the node graph editor.

Purpose: This plan sets up the core dependencies, data structures, and rendering pipeline needed for all subsequent node graph functionality. Without this foundation, no visual node editing is possible.

Output: A working ExperimentDesignerPanel that displays an empty (but interactive) node graph canvas with pan/zoom support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-node-graph-editor-core/02-RESEARCH.md

# Phase 01 established egui panel patterns:
@.planning/phases/01-form-based-scan-builder/01-01-SUMMARY.md

# Existing crate structure:
@crates/daq-egui/Cargo.toml
@crates/daq-egui/src/panels/mod.rs
@crates/daq-egui/src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add egui-snarl and undo dependencies</name>
  <files>crates/daq-egui/Cargo.toml</files>
  <action>
Add dependencies to daq-egui Cargo.toml:

```toml
egui-snarl = { version = "0.9", features = ["serde"] }
undo = "3"
```

The `serde` feature is required for graph serialization in later plans.

Do NOT add petgraph yet - only add it when graph algorithms (cycle detection, topological sort) are actually needed.
  </action>
  <verify>`cargo check -p daq-egui` succeeds with new dependencies</verify>
  <done>egui-snarl 0.9 and undo 3 appear in Cargo.toml and resolve correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create graph module with ExperimentNode and SnarlViewer</name>
  <files>
crates/daq-egui/src/graph/mod.rs
crates/daq-egui/src/graph/nodes.rs
crates/daq-egui/src/graph/viewer.rs
  </files>
  <action>
Create the `graph` module directory and files:

**mod.rs:**
- Export `nodes::ExperimentNode`
- Export `viewer::ExperimentViewer`
- Re-export `egui_snarl::Snarl` for convenience

**nodes.rs:**
Define the ExperimentNode enum representing node types for experiment workflows:

```rust
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ExperimentNode {
    /// 1D or 2D parameter scan
    Scan {
        actuator: String,        // Device ID for movable
        start: f64,
        stop: f64,
        points: u32,
    },
    /// Single acquisition from detector
    Acquire {
        detector: String,        // Device ID for readable/camera
        duration_ms: f64,
    },
    /// Move actuator to position
    Move {
        device: String,
        position: f64,
    },
    /// Wait/delay step
    Wait {
        duration_ms: f64,
    },
    /// Loop control node
    Loop {
        iterations: u32,
    },
}
```

Add helper methods:
- `node_name(&self) -> &'static str` - returns human-readable name ("Scan", "Acquire", etc.)
- `default_*()` constructors for each variant with sensible defaults

**viewer.rs:**
Implement `SnarlViewer<ExperimentNode>`:

```rust
use egui_snarl::{SnarlViewer, InPin, OutPin, ui::PinInfo};
use egui::Ui;

pub struct ExperimentViewer {
    // Will hold validation errors in later plans
}

impl ExperimentViewer {
    pub fn new() -> Self { Self {} }
}

impl SnarlViewer<ExperimentNode> for ExperimentViewer {
    fn title(&self, node: &ExperimentNode) -> String {
        node.node_name().to_string()
    }

    fn inputs(&self, node: &ExperimentNode) -> usize {
        match node {
            ExperimentNode::Scan { .. } => 0,  // Entry point, no inputs
            ExperimentNode::Loop { .. } => 1,  // Has body input
            _ => 1,  // Sequential flow input
        }
    }

    fn outputs(&self, node: &ExperimentNode) -> usize {
        match node {
            ExperimentNode::Loop { .. } => 2,  // Next + loop body outputs
            _ => 1,  // Sequential flow output
        }
    }

    fn show_input(&mut self, _pin: &InPin, ui: &mut Ui, _scale: f32,
                  _snarl: &mut Snarl<ExperimentNode>) -> PinInfo {
        ui.label(">");  // Flow input indicator
        PinInfo::default()
    }

    fn show_output(&mut self, _pin: &OutPin, ui: &mut Ui, _scale: f32,
                   _snarl: &mut Snarl<ExperimentNode>) -> PinInfo {
        ui.label(">");  // Flow output indicator
        PinInfo::default()
    }

    // show_body: render node-specific content (parameters)
    // This will be expanded in Plan 02-03 for property editing
}
```

NOTE: Consult egui-snarl 0.9 docs for exact trait method signatures - they may have changed from examples in research.
  </action>
  <verify>`cargo check -p daq-egui` compiles with graph module</verify>
  <done>graph/mod.rs exports ExperimentNode and ExperimentViewer; nodes.rs has 5 node variants; viewer.rs implements SnarlViewer trait</done>
</task>

<task type="auto">
  <name>Task 3: Create ExperimentDesignerPanel with graph canvas</name>
  <files>
crates/daq-egui/src/panels/experiment_designer.rs
crates/daq-egui/src/panels/mod.rs
crates/daq-egui/src/app.rs
  </files>
  <action>
**experiment_designer.rs:**
Create the main panel that hosts the node graph editor:

```rust
use egui_snarl::{Snarl, ui::SnarlStyle};
use crate::graph::{ExperimentNode, ExperimentViewer};

pub struct ExperimentDesignerPanel {
    snarl: Snarl<ExperimentNode>,
    viewer: ExperimentViewer,
    style: SnarlStyle,
}

impl Default for ExperimentDesignerPanel {
    fn default() -> Self {
        Self {
            snarl: Snarl::new(),
            viewer: ExperimentViewer::new(),
            style: SnarlStyle::default(),
        }
    }
}

impl ExperimentDesignerPanel {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // Toolbar placeholder (will add buttons in later plans)
        ui.horizontal(|ui| {
            ui.label("Experiment Designer");
            ui.separator();
            ui.label("(Empty canvas - drag nodes from palette)");
        });

        ui.separator();

        // Graph canvas - takes remaining space
        egui::Frame::canvas(ui.style()).show(ui, |ui| {
            let id = egui::Id::new("experiment_graph");
            self.snarl.show(&mut self.viewer, &self.style, id, ui);
        });
    }
}
```

**mod.rs:**
Add `pub mod experiment_designer;` and export `ExperimentDesignerPanel`.

**app.rs:**
1. Add `Panel::ExperimentDesigner` variant to the Panel enum
2. Add `experiment_designer_panel: ExperimentDesignerPanel` field to DaqApp
3. In TabViewer::title(), return "Experiment Designer" for this variant
4. In TabViewer::ui(), call `self.experiment_designer_panel.ui(ui)` for this variant
5. Add navigation button in the "Experiment" section of the left sidebar (next to Scan Builder)
6. Add View menu entry for quick access

Follow the exact pattern used for ScanBuilderPanel integration in Phase 01-01.
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI with mock daemon, open "Experiment Designer" panel
3. Verify empty canvas renders without panic
4. Verify pan (middle-drag) and zoom (scroll) work on canvas
  </verify>
  <done>ExperimentDesignerPanel shows in dock system, displays empty interactive canvas</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cargo build -p daq-egui
   cargo clippy -p daq-egui -- -D warnings
   ```

2. **Structural verification:**
   - `crates/daq-egui/src/graph/` directory exists with mod.rs, nodes.rs, viewer.rs
   - ExperimentNode has Scan, Acquire, Move, Wait, Loop variants
   - ExperimentViewer implements SnarlViewer trait
   - ExperimentDesignerPanel integrated into app dock system

3. **Runtime verification:**
   - Launch GUI, Experiment Designer panel available
   - Canvas renders without errors
   - Pan/zoom functional
</verification>

<success_criteria>
- egui-snarl 0.9 and undo 3 dependencies added and resolve
- graph module created with ExperimentNode enum (5 variants) and ExperimentViewer
- ExperimentDesignerPanel visible in GUI dock with interactive empty canvas
- All code compiles without warnings
- Pan and zoom work on the graph canvas
</success_criteria>

<output>
After completion, create `.planning/phases/02-node-graph-editor-core/02-01-SUMMARY.md`
</output>
