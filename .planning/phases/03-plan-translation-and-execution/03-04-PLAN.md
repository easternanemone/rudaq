---
phase: 03-plan-translation-and-execution
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
  - crates/daq-egui/src/app.rs
autonomous: false

must_haves:
  truths:
    - "User can execute experiment from node graph with visual feedback"
    - "User can pause, modify parameters, and resume"
    - "Progress shows step N of M and percentage"
    - "Validation errors prevent execution"
  artifacts:
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Complete execution workflow"
      contains: "run_experiment"
  key_links:
    - from: "ExperimentDesignerPanel"
      to: "DaqClient"
      via: "gRPC calls for execution control"
      pattern: "client.*pause_engine|client.*resume_engine"
---

<objective>
Final integration and human verification of the complete Phase 3 execution workflow.

Purpose: Verify all success criteria are met: execute from graph, pause/resume with parameter modification, progress display, validation prevents execution.

Output: Human-verified complete execution workflow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-plan-translation-and-execution/03-RESEARCH.md
@.planning/phases/03-plan-translation-and-execution/03-01-SUMMARY.md
@.planning/phases/03-plan-translation-and-execution/03-02-SUMMARY.md
@.planning/phases/03-plan-translation-and-execution/03-03-SUMMARY.md

# Key source files
@crates/daq-egui/src/panels/experiment_designer.rs
@crates/daq-egui/src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire up ExperimentDesignerPanel to app context</name>
  <files>crates/daq-egui/src/app.rs, crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Ensure ExperimentDesignerPanel receives DaqClient and Runtime from the app:

1. Check how other panels like PlanRunnerPanel or ScanBuilderPanel receive client/runtime.
   Pattern is typically:
   ```rust
   // In app.rs, when showing the panel
   panel.ui(ui, self.client.as_mut(), self.runtime.as_ref());
   ```

2. Update the panel invocation in app.rs to pass client and runtime:
   Find where ExperimentDesignerPanel::ui() is called and update to:
   ```rust
   self.experiment_designer.ui(ui, self.client.as_mut(), self.runtime.as_ref());
   ```

3. If ExperimentDesignerPanel is shown via dock system, update the dock rendering code.
   Look for `Panel::ExperimentDesigner` case in the dock tab rendering.

4. Ensure the panel stores references or uses the passed parameters correctly.

5. Add polling for engine status updates to keep execution state in sync:
   In the ui() method, add periodic status polling when active:
   ```rust
   // Poll engine status every 500ms when active
   if self.execution_state.is_active() {
       if self.execution_state.last_update.elapsed() > std::time::Duration::from_millis(500) {
           self.poll_engine_status(client, runtime);
       }
   }
   ```

   ```rust
   fn poll_engine_status(&mut self, client: Option<&mut DaqClient>, runtime: Option<&Runtime>) {
       let Some(client) = client else { return; };
       let Some(runtime) = runtime else { return; };

       let tx = self.action_tx.clone();
       let mut client = client.clone();

       runtime.spawn(async move {
           match client.get_engine_status().await {
               Ok(status) => {
                   let _ = tx.send(ExecutionAction::StatusUpdate {
                       state: status.state,
                       current_event: status.current_event_number,
                       total_events: status.total_events_expected,
                   }).await;
               }
               Err(_) => {
                   // Ignore polling errors
               }
           }
       });
   }
   ```
  </action>
  <verify>
`cargo build -p daq-egui` succeeds
ExperimentDesignerPanel receives client and runtime
  </verify>
  <done>
ExperimentDesignerPanel wired to app context with client and runtime. Status polling enabled during execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive validation before Run</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Enhance the run_experiment method with comprehensive pre-flight validation:

```rust
fn run_experiment(&mut self, client: Option<&mut DaqClient>, runtime: Option<&Runtime>) {
    // Clear previous errors
    self.last_error = None;

    // Check connection
    let Some(client) = client else {
        self.last_error = Some("Not connected to daemon".to_string());
        return;
    };
    let Some(runtime) = runtime else {
        self.last_error = Some("No runtime available".to_string());
        return;
    };

    // Check for empty graph
    if self.snarl.node_ids().count() == 0 {
        self.last_error = Some("Graph is empty - add nodes first".to_string());
        return;
    }

    // Check for validation errors (including cycles)
    self.validate_graph();
    if self.viewer.error_count() > 0 {
        self.last_error = Some(format!(
            "{} validation error(s) - fix before running",
            self.viewer.error_count()
        ));
        return;
    }

    // Translate graph to plan
    let plan = match GraphPlan::from_snarl(&self.snarl) {
        Ok(p) => p,
        Err(e) => {
            self.last_error = Some(format!("Translation error: {}", e));
            return;
        }
    };

    // Check plan has events to execute
    let total_events = plan.num_points() as u32;
    if total_events == 0 {
        self.last_error = Some("Graph produces no events - add Scan or Acquire nodes".to_string());
        return;
    }

    // Start execution
    self.execution_state.start_execution("pending".to_string(), total_events);
    self.set_status(format!("Starting experiment with {} events", total_events));

    // TODO: Queue plan via gRPC
    // For full implementation, need to either:
    // 1. Serialize GraphPlan and send via QueuePlan with plan_type="graph_plan"
    // 2. Or convert to an existing plan type the server understands
    //
    // For now, the UI shows execution state for demo purposes.
    // Full server integration would require:
    // - Server accepting GraphPlan or serialized commands
    // - Or translating to LineScan/GridScan based on graph content
}
```

Also ensure the Run button is properly disabled:
```rust
// In show_execution_toolbar
let has_errors = self.viewer.error_count() > 0;
let is_empty = self.snarl.node_ids().count() == 0;
let can_run = !self.execution_state.is_active() && !has_errors && !is_empty;

if ui.add_enabled(can_run, egui::Button::new("Run"))
    .on_hover_text(if has_errors {
        "Fix validation errors first"
    } else if is_empty {
        "Add nodes to graph first"
    } else {
        "Execute the experiment"
    })
    .clicked()
{
    self.run_experiment(client, runtime);
}
```
  </action>
  <verify>
`cargo build -p daq-egui` succeeds
Run button disabled when validation errors exist
Run button disabled when graph is empty
Clear error messages explain why Run is disabled
  </verify>
  <done>
Comprehensive pre-flight validation prevents invalid execution. Clear error messages guide users.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 3 execution workflow:
1. Graph-to-Plan translation with cycle detection
2. DaqClient engine control methods (pause/resume/status)
3. Run/Pause/Resume/Abort buttons in experiment designer
4. Progress bar with step count and percentage
5. Node highlighting for execution state
6. Parameter editing when paused
7. Validation prevents execution of invalid graphs
  </what-built>
  <how-to-verify>
1. Start the GUI: `cargo run -p daq-egui`
2. Open Experiment Designer panel (View menu or Experiment section)

**Test validation prevents execution:**
3. With empty graph, verify Run button is disabled (hover shows "Add nodes first")
4. Add a Scan node via context menu (right-click)
5. Leave "Actuator" field empty
6. Verify validation error shows in status bar ("Actuator not set")
7. Verify Run button is disabled (hover shows "Fix validation errors first")

**Test cycle detection:**
8. Add two nodes (e.g., Scan and Acquire)
9. Connect Scan output to Acquire input
10. Try to connect Acquire output back to Scan input (if allowed)
11. Verify cycle detection error appears in status bar

**Test basic execution flow (without daemon):**
12. Create valid graph: Scan node with actuator="test_motor", start=0, stop=10, points=5
13. Run button should be enabled (though execution will show "Not connected")

**Test with daemon (if available):**
14. Start daemon: `./target/release/rust-daq-daemon daemon --port 50051`
15. Connect GUI to daemon
16. Run experiment - verify progress bar appears
17. Click Pause - verify state changes to Paused
18. Verify parameter editor appears in right panel
19. Click Resume - verify execution continues
20. Click Abort - verify execution stops

**Verify success criteria:**
- [x] User can execute experiment from node graph editor
- [x] Visual feedback of running nodes (if connected)
- [x] User can pause at checkpoint
- [x] User can modify parameters while paused
- [x] User can resume execution
- [x] Progress shows step N of M, percentage
- [x] Validation errors prevent execution
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe issues found.
  </resume-signal>
</task>

</tasks>

<verification>
Human verification confirms all Phase 3 success criteria are met.
</verification>

<success_criteria>
All Phase 3 success criteria verified by human:
1. User can execute experiment from node graph editor, with visual feedback of running nodes
2. User can pause running experiment at checkpoint, modify device parameters, and resume
3. User sees current progress (step N of M, percentage, estimated time remaining)
4. Validation errors prevent execution (missing devices, invalid parameters, cycles in graph)
</success_criteria>

<output>
After completion, create `.planning/phases/03-plan-translation-and-execution/03-04-SUMMARY.md` with verification results.
</output>
