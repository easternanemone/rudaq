---
phase: 08-advanced-scans
plan: 05
type: execute
wave: 2
depends_on: ["08-03"]
files_modified:
  - crates/daq-egui/src/graph/translation.rs
  - crates/daq-egui/src/graph/validation.rs
  - crates/daq-egui/src/graph/codegen.rs
  - crates/daq-egui/src/graph/adaptive.rs
autonomous: true

must_haves:
  truths:
    - "AdaptiveScan translates to scan with trigger evaluation points"
    - "Peak detection triggers use find_peaks algorithm"
    - "Code generation includes trigger condition comments"
  artifacts:
    - path: "crates/daq-egui/src/graph/translation.rs"
      provides: "AdaptiveScan translation to PlanCommands"
      contains: "AdaptiveScan"
    - path: "crates/daq-egui/src/graph/adaptive.rs"
      provides: "Trigger evaluation logic"
      exports: ["evaluate_trigger", "detect_peaks"]
  key_links:
    - from: "crates/daq-egui/src/graph/adaptive.rs"
      to: "find_peaks crate"
      via: "PeakFinder usage"
      pattern: "PeakFinder::new"
---

<objective>
Implement translation and trigger evaluation for AdaptiveScan nodes.

Purpose: AdaptiveScan nodes must translate to executable scans with trigger checkpoints. This plan implements the runtime trigger evaluation logic using find_peaks.

Output: AdaptiveScan translation with trigger evaluation module
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-scans/08-03-SUMMARY.md
@.planning/phases/08-advanced-scans/08-RESEARCH.md
@crates/daq-egui/src/graph/translation.rs
@crates/daq-egui/src/graph/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adaptive trigger evaluation module</name>
  <files>crates/daq-egui/src/graph/adaptive.rs, crates/daq-egui/src/graph/mod.rs</files>
  <action>
Create adaptive.rs module for trigger evaluation:

1. **Module structure**:
```rust
//! Adaptive scan trigger evaluation.
//!
//! Provides runtime evaluation of trigger conditions for adaptive scans.
//! Triggers can detect threshold crossings or peaks in signal data.

use crate::graph::nodes::{TriggerCondition, ThresholdOp, AdaptiveAction, TriggerLogic};
use find_peaks::PeakFinder;
```

2. **Peak detection function**:
```rust
/// Detected peak information.
#[derive(Debug, Clone)]
pub struct DetectedPeak {
    /// Index in the signal array
    pub index: usize,
    /// Signal value at peak
    pub height: f64,
    /// Position (if axis values provided)
    pub position: Option<f64>,
}

/// Detect peaks in a signal using prominence-based filtering.
///
/// # Arguments
/// * `signal` - Signal values to analyze
/// * `min_prominence` - Minimum prominence for peak detection
/// * `min_height` - Optional minimum height threshold
///
/// # Returns
/// Vector of detected peaks sorted by height (highest first)
pub fn detect_peaks(
    signal: &[f64],
    min_prominence: f64,
    min_height: Option<f64>,
) -> Vec<DetectedPeak> {
    let mut fp = PeakFinder::new(signal);
    fp.with_min_prominence(min_prominence);

    if let Some(height) = min_height {
        fp.with_min_height(height);
    }

    let mut peaks: Vec<DetectedPeak> = fp.find_peaks()
        .iter()
        .map(|p| DetectedPeak {
            index: p.middle_position(),
            height: p.height.unwrap_or(0.0),
            position: None,
        })
        .collect();

    // Sort by height descending
    peaks.sort_by(|a, b| b.height.partial_cmp(&a.height).unwrap_or(std::cmp::Ordering::Equal));

    peaks
}
```

3. **Threshold evaluation function**:
```rust
/// Evaluate a threshold condition against current value.
pub fn evaluate_threshold(
    value: f64,
    operator: &ThresholdOp,
    threshold: f64,
) -> bool {
    match operator {
        ThresholdOp::LessThan => value < threshold,
        ThresholdOp::GreaterThan => value > threshold,
        ThresholdOp::EqualWithin { tolerance } => (value - threshold).abs() <= *tolerance,
    }
}
```

4. **Full trigger evaluation**:
```rust
/// Result of trigger evaluation.
#[derive(Debug, Clone)]
pub struct TriggerResult {
    /// Whether the trigger fired
    pub fired: bool,
    /// Detected peak (if peak detection trigger)
    pub peak: Option<DetectedPeak>,
    /// Which trigger(s) fired
    pub fired_triggers: Vec<usize>,
}

/// Evaluate trigger conditions against scan data.
///
/// # Arguments
/// * `triggers` - Trigger conditions to evaluate
/// * `logic` - AND/OR logic for combining triggers
/// * `signal` - Current signal data from scan
/// * `positions` - Optional position values corresponding to signal
///
/// # Returns
/// TriggerResult indicating whether triggers fired and any detected peaks
pub fn evaluate_triggers(
    triggers: &[TriggerCondition],
    logic: &TriggerLogic,
    signal: &[f64],
    positions: Option<&[f64]>,
) -> TriggerResult {
    let mut fired_triggers = Vec::new();
    let mut detected_peak = None;

    for (idx, trigger) in triggers.iter().enumerate() {
        let fired = match trigger {
            TriggerCondition::Threshold { operator, value, .. } => {
                // Check if any signal value crosses threshold
                signal.iter().any(|&v| evaluate_threshold(v, operator, *value))
            }
            TriggerCondition::PeakDetection { min_prominence, min_height, .. } => {
                let peaks = detect_peaks(signal, *min_prominence, *min_height);
                if let Some(peak) = peaks.first() {
                    // Add position if available
                    let mut peak_with_pos = peak.clone();
                    if let Some(positions) = positions {
                        if peak.index < positions.len() {
                            peak_with_pos.position = Some(positions[peak.index]);
                        }
                    }
                    detected_peak = Some(peak_with_pos);
                    true
                } else {
                    false
                }
            }
        };

        if fired {
            fired_triggers.push(idx);
        }
    }

    let overall_fired = match logic {
        TriggerLogic::Any => !fired_triggers.is_empty(),
        TriggerLogic::All => fired_triggers.len() == triggers.len(),
    };

    TriggerResult {
        fired: overall_fired,
        peak: detected_peak,
        fired_triggers,
    }
}
```

5. **Export in mod.rs**:
```rust
mod adaptive;
pub use adaptive::{detect_peaks, evaluate_triggers, DetectedPeak, TriggerResult};
```
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>Trigger evaluation module with peak detection and threshold logic</done>
</task>

<task type="auto">
  <name>Task 2: Add AdaptiveScan translation</name>
  <files>crates/daq-egui/src/graph/translation.rs</files>
  <action>
Add AdaptiveScan handling in translate_node_with_snarl():

1. **Match arm for AdaptiveScan**:
```rust
ExperimentNode::AdaptiveScan(config) => {
    // Add actuator to movers
    if !config.scan.actuator.is_empty() {
        movers.push(config.scan.actuator.clone());
    }

    // Calculate step size
    let step = if config.scan.points > 1 {
        (config.scan.stop - config.scan.start) / (config.scan.points as f64 - 1.0)
    } else { 0.0 };

    // Add adaptive scan start checkpoint
    commands.push(PlanCommand::Checkpoint {
        label: format!("adaptive_{:?}_start", node_id),
    });

    // Generate scan points
    for i in 0..config.scan.points {
        let pos = config.scan.start + step * i as f64;

        // Move actuator
        if !config.scan.actuator.is_empty() {
            commands.push(PlanCommand::MoveTo {
                device_id: config.scan.actuator.clone(),
                position: pos,
            });
        }

        // Point checkpoint with trigger metadata
        commands.push(PlanCommand::Checkpoint {
            label: format!("adaptive_{:?}_point_{}_triggers_{}",
                          node_id, i, config.triggers.len()),
        });

        // Emit event
        let positions = if !config.scan.actuator.is_empty() {
            [(config.scan.actuator.clone(), pos)].into_iter().collect()
        } else {
            HashMap::new()
        };
        commands.push(PlanCommand::EmitEvent {
            stream: "primary".to_string(),
            data: HashMap::new(),
            positions,
        });
        events += 1;
    }

    // Add adaptive evaluation checkpoint
    // NOTE: Actual trigger evaluation happens at runtime in RunEngine
    // This checkpoint signals where the adaptive decision occurs
    commands.push(PlanCommand::Checkpoint {
        label: format!("adaptive_{:?}_evaluate_action_{:?}",
                      node_id, config.action),
    });

    // If require_approval, add a pause checkpoint
    if config.require_approval {
        commands.push(PlanCommand::Checkpoint {
            label: format!("adaptive_{:?}_approval_required", node_id),
        });
    }
}
```

2. **NOTE about runtime evaluation**:
The translation generates checkpoints that mark where trigger evaluation should occur. The actual evaluation (calling `evaluate_triggers()`) happens in the RunEngine at runtime when data is available.

This follows the pattern where translation generates the structure, and runtime fills in the dynamic behavior.
  </action>
  <verify>
Run: `cargo test -p daq-egui -- adaptive`
Should compile without errors.
  </verify>
  <done>AdaptiveScan translation with trigger evaluation checkpoints</done>
</task>

<task type="auto">
  <name>Task 3: Add AdaptiveScan validation and code generation</name>
  <files>crates/daq-egui/src/graph/validation.rs, crates/daq-egui/src/graph/codegen.rs</files>
  <action>
1. **Add validation in validation.rs**:
```rust
fn validate_adaptive_scan(config: &AdaptiveScanConfig) -> Vec<String> {
    let mut errors = Vec::new();

    // Validate base scan
    if config.scan.actuator.is_empty() {
        errors.push("Adaptive scan: device not selected".to_string());
    }
    if config.scan.points == 0 {
        errors.push("Adaptive scan: points must be > 0".to_string());
    }

    // Validate triggers
    if config.triggers.is_empty() {
        errors.push("Adaptive scan: at least one trigger required".to_string());
    }

    for (i, trigger) in config.triggers.iter().enumerate() {
        match trigger {
            TriggerCondition::Threshold { device_id, .. } => {
                if device_id.is_empty() {
                    errors.push(format!("Trigger {}: device not selected", i + 1));
                }
            }
            TriggerCondition::PeakDetection { device_id, min_prominence, .. } => {
                if device_id.is_empty() {
                    errors.push(format!("Trigger {}: device not selected", i + 1));
                }
                if *min_prominence <= 0.0 {
                    errors.push(format!("Trigger {}: prominence must be > 0", i + 1));
                }
            }
        }
    }

    errors
}
```

2. **Add to validate_node()**:
```rust
ExperimentNode::AdaptiveScan(config) => {
    errors.extend(validate_adaptive_scan(config));
}
```

3. **Add code generation in codegen.rs**:
```rust
ExperimentNode::AdaptiveScan(config) => {
    let mut code = String::new();

    // Comment describing the adaptive scan
    code.push_str(&format!(
        "// Adaptive scan: {} points, {} trigger(s)\n",
        config.scan.points,
        config.triggers.len()
    ));

    // Describe triggers
    for (i, trigger) in config.triggers.iter().enumerate() {
        match trigger {
            TriggerCondition::Threshold { device_id, operator, value } => {
                let op_str = match operator {
                    ThresholdOp::LessThan => "<",
                    ThresholdOp::GreaterThan => ">",
                    ThresholdOp::EqualWithin { .. } => "â‰ˆ",
                };
                code.push_str(&format!(
                    "// Trigger {}: {} {} {:.1}\n",
                    i + 1, device_id, op_str, value
                ));
            }
            TriggerCondition::PeakDetection { device_id, min_prominence, .. } => {
                code.push_str(&format!(
                    "// Trigger {}: peak detection on {} (prominence > {:.1})\n",
                    i + 1, device_id, min_prominence
                ));
            }
        }
    }

    // Action description
    let action_str = match config.action {
        AdaptiveAction::Zoom2x => "zoom 2x",
        AdaptiveAction::Zoom4x => "zoom 4x",
        AdaptiveAction::MoveToPeak => "move to peak",
        AdaptiveAction::AcquireAtPeak => "acquire at peak",
        AdaptiveAction::MarkAndContinue => "mark and continue",
    };
    code.push_str(&format!("// Action: {}\n\n", action_str));

    // Generate scan loop
    let var = sanitize_varname(&config.scan.dimension_name);
    let step = if config.scan.points > 1 {
        (config.scan.stop - config.scan.start) / (config.scan.points as f64 - 1.0)
    } else { 0.0 };

    code.push_str(&format!(
        "let scan_data = [];\n\
         for {}_idx in 0..{} {{\n\
             let pos = {:.1} + {:.4} * {}_idx;\n",
        var, config.scan.points, config.scan.start, step, var
    ));

    if !config.scan.actuator.is_empty() {
        code.push_str(&format!(
            "    move_to(\"{}\", pos);\n",
            config.scan.actuator
        ));
    }

    code.push_str("    let reading = read_value(\"detector\");\n");
    code.push_str("    scan_data.push(reading);\n");
    code.push_str("    checkpoint();\n");
    code.push_str("}\n\n");

    // Trigger evaluation comment
    code.push_str("// Evaluate triggers and execute action\n");
    code.push_str(&format!("// (Runtime: {})\n", action_str));

    code
}
```
  </action>
  <verify>
Run: `cargo test -p daq-egui`
Should pass all tests.
  </verify>
  <done>AdaptiveScan validation and code generation with trigger comments</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `cargo build -p daq-egui`
2. Tests: `cargo test -p daq-egui`
3. Format/lint: `cargo fmt --all && cargo clippy -p daq-egui`
4. Unit test peak detection:
   - Test detect_peaks with synthetic signal (known peaks)
   - Test evaluate_threshold with boundary values
</verification>

<success_criteria>
- detect_peaks returns correct peak indices for test signals
- evaluate_triggers correctly combines AND/OR logic
- AdaptiveScan translation includes trigger evaluation checkpoints
- Code generation shows trigger conditions as comments
- Validation catches missing devices and invalid prominence
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-scans/08-05-SUMMARY.md`
</output>
