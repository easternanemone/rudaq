---
phase: 08-advanced-scans
plan: 06
type: execute
wave: 3
depends_on: ["08-01", "08-04"]
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
  - crates/daq-egui/src/graph/execution_state.rs
autonomous: true

must_haves:
  truths:
    - "User sees nested progress during execution (Outer 3/10, Inner 45/100)"
    - "Progress can toggle between nested and flattened view"
    - "Nested scans write to Zarr format with proper dimensional metadata"
  artifacts:
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Nested progress display in execution state"
      contains: "NestedProgress"
    - path: "crates/daq-egui/src/graph/execution_state.rs"
      provides: "Nested progress tracking structure"
      contains: "NestedProgress"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "execution_state.rs"
      via: "NestedProgress display"
      pattern: "nested_progress"
---

<objective>
Implement nested progress display for multi-dimensional scans.

Purpose: Scientists need clear feedback during nested scans showing both outer and inner progress. The default view shows "Outer 3/10, Inner 45/100" with a toggle to flatten.

Output: Nested progress UI with Zarr integration for data storage
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-scans/08-01-SUMMARY.md
@.planning/phases/08-advanced-scans/08-04-SUMMARY.md
@crates/daq-egui/src/panels/experiment_designer.rs
@crates/daq-egui/src/graph/execution_state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nested progress tracking to ExecutionState</name>
  <files>crates/daq-egui/src/graph/execution_state.rs</files>
  <action>
Extend ExecutionState to track nested progress:

1. **NestedProgress struct**:
```rust
/// Progress for a single dimension of a nested scan.
#[derive(Clone, Debug, Default)]
pub struct DimensionProgress {
    /// Dimension name (e.g., "wavelength", "position_x")
    pub name: String,
    /// Current index (0-based)
    pub current: u32,
    /// Total points in this dimension
    pub total: u32,
}

/// Nested scan progress tracking.
#[derive(Clone, Debug, Default)]
pub struct NestedProgress {
    /// Progress for each dimension (outer to inner order)
    pub dimensions: Vec<DimensionProgress>,
    /// Flattened total progress
    pub flat_current: u32,
    /// Flattened total points
    pub flat_total: u32,
}

impl NestedProgress {
    /// Create progress for a simple 1D scan.
    pub fn simple(current: u32, total: u32) -> Self {
        Self {
            dimensions: vec![DimensionProgress {
                name: "scan".to_string(),
                current,
                total,
            }],
            flat_current: current,
            flat_total: total,
        }
    }

    /// Create progress for a 2D nested scan.
    pub fn nested_2d(
        outer_name: &str, outer_current: u32, outer_total: u32,
        inner_name: &str, inner_current: u32, inner_total: u32,
    ) -> Self {
        let flat_total = outer_total * inner_total;
        let flat_current = outer_current * inner_total + inner_current;

        Self {
            dimensions: vec![
                DimensionProgress {
                    name: outer_name.to_string(),
                    current: outer_current,
                    total: outer_total,
                },
                DimensionProgress {
                    name: inner_name.to_string(),
                    current: inner_current,
                    total: inner_total,
                },
            ],
            flat_current,
            flat_total,
        }
    }

    /// Format as nested string: "Outer 3/10, Inner 45/100"
    pub fn format_nested(&self) -> String {
        self.dimensions
            .iter()
            .map(|d| format!("{} {}/{}", d.name, d.current + 1, d.total))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Format as flat string: "345/1000 (34.5%)"
    pub fn format_flat(&self) -> String {
        if self.flat_total > 0 {
            let pct = 100.0 * self.flat_current as f64 / self.flat_total as f64;
            format!("{}/{} ({:.1}%)", self.flat_current, self.flat_total, pct)
        } else {
            "0/0".to_string()
        }
    }
}
```

2. **Add to ExecutionState struct**:
```rust
pub struct ExecutionState {
    // ... existing fields
    /// Nested progress tracking (None for non-nested scans)
    pub nested_progress: Option<NestedProgress>,
}
```

3. **Update ExecutionState::new() and related methods**:
- Initialize nested_progress to None
- Add setter: `pub fn set_nested_progress(&mut self, progress: NestedProgress)`
- Add method to update from checkpoint label:
```rust
/// Parse checkpoint label and update nested progress.
pub fn update_from_checkpoint(&mut self, label: &str) {
    // Parse labels like "nested_{:?}_outer_{}_inner_{}"
    if label.starts_with("nested_") && label.contains("_outer_") && label.contains("_inner_") {
        // Extract indices from label
        // Update nested_progress accordingly
    }
}
```

4. **Ensure clone/default impls are updated** if ExecutionState derives them.
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>NestedProgress struct with format_nested() and format_flat() methods</done>
</task>

<task type="auto">
  <name>Task 2: Add nested progress display to ExperimentDesignerPanel</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Update the execution progress display UI:

1. **Add toggle state** to ExperimentDesignerPanel:
```rust
/// Whether to show flattened progress (false = nested view)
show_flattened_progress: bool,
```

Initialize to `false` in Default impl.

2. **Update progress display** in the UI rendering code:

Find where current progress is displayed (likely near status bar or execution controls) and replace/extend:

```rust
// In the execution state display section
if let Some(ref nested) = self.execution_state.nested_progress {
    ui.horizontal(|ui| {
        // Toggle button
        if ui.selectable_label(!self.show_flattened_progress, "Nested").clicked() {
            self.show_flattened_progress = false;
        }
        if ui.selectable_label(self.show_flattened_progress, "Flat").clicked() {
            self.show_flattened_progress = true;
        }

        ui.separator();

        // Progress text
        let progress_text = if self.show_flattened_progress {
            nested.format_flat()
        } else {
            nested.format_nested()
        };
        ui.label(progress_text);
    });

    // Progress bar (always uses flat values)
    let progress = nested.flat_current as f32 / nested.flat_total.max(1) as f32;
    ui.add(egui::ProgressBar::new(progress).show_percentage());
} else {
    // Fallback to simple progress display
    // (existing code)
}
```

3. **Update execution state from async actions**:
When processing ExecutionAction::StatusUpdate, check if we have nested scan context and create appropriate NestedProgress:

```rust
ExecutionAction::StatusUpdate { current_event, total_events, .. } => {
    if let (Some(current), Some(total)) = (current_event, total_events) {
        // Check if this is a nested scan by inspecting the running graph
        // For MVP, assume simple progress; nested detection in future iteration
        self.execution_state.set_progress(current, total);
    }
}
```

Note: Full nested progress detection requires inspecting the graph during execution. For Phase 8 MVP, the nested progress is set when NestedScan node is executing, detected via checkpoint labels.
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>Progress UI with nested/flat toggle showing dimensional progress</done>
</task>

<task type="auto">
  <name>Task 3: Document Zarr integration points for nested scan data</name>
  <files>crates/daq-egui/src/graph/translation.rs</files>
  <action>
Add comments and TODO markers for Zarr integration:

1. **Add TODO comment in NestedScan translation**:

After the nested iteration loop generation, add:

```rust
// TODO (Phase 8 Zarr integration):
// When Zarr storage is enabled:
// 1. Create ZarrWriter at run start with shape [outer.points, inner.points, ...]
// 2. Each EmitEvent writes to corresponding chunk indices
// 3. Dimension names from config.outer.dimension_name and config.inner.dimension_name
//    become `_ARRAY_DIMENSIONS` attribute for Xarray compatibility
//
// Example setup:
//   let writer = ZarrWriter::new(output_path)?;
//   let array = writer.create_array()
//       .shape(vec![outer.points as u64, inner.points as u64])
//       .dimensions(vec![outer.dimension_name.clone(), inner.dimension_name.clone()])
//       .dtype::<f64>()
//       .build("data")?;
```

2. **Add dimensional metadata to EmitEvent**:
Update the EmitEvent command to include dimension indices in the data field:

```rust
// Include dimensional indices in event data
let mut data = HashMap::new();
data.insert("outer_idx".to_string(), serde_json::to_string(&outer_idx).unwrap());
data.insert("inner_idx".to_string(), serde_json::to_string(&inner_idx).unwrap());
data.insert("outer_dim".to_string(), config.outer.dimension_name.clone());
data.insert("inner_dim".to_string(), config.inner.dimension_name.clone());

commands.push(PlanCommand::EmitEvent {
    stream: "primary".to_string(),
    data,
    positions,
});
```

This metadata allows the storage layer to place data at correct array indices.

3. **Note in codegen for dimension metadata**:
Add comment in generated Rhai code:
```rust
code.push_str("// Dimensional metadata for Zarr storage:\n");
code.push_str(&format!(
    "//   outer: {} [{} points]\n",
    config.outer.dimension_name, config.outer.points
));
code.push_str(&format!(
    "//   inner: {} [{} points]\n",
    config.inner.dimension_name, config.inner.points
));
```
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>Zarr integration documentation and dimensional metadata in EmitEvent</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `cargo build -p daq-egui`
2. Tests: `cargo test -p daq-egui`
3. Format/lint: `cargo fmt --all && cargo clippy -p daq-egui`
4. Manual verification: Run GUI, create NestedScan, verify progress display shows "Outer X/Y, Inner Z/W"
</verification>

<success_criteria>
- NestedProgress.format_nested() returns "wavelength 3/10, position 45/100" style string
- NestedProgress.format_flat() returns "345/1000 (34.5%)" style string
- Toggle button switches between nested and flat progress views
- Progress bar uses flat values for accurate completion percentage
- EmitEvent includes dimensional indices for Zarr storage
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-scans/08-06-SUMMARY.md`
</output>
