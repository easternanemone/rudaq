---
phase: 08-advanced-scans
plan: 07
type: execute
wave: 3
depends_on: ["08-05"]
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
  - crates/daq-egui/src/widgets/adaptive_alert.rs
  - crates/daq-egui/src/widgets/mod.rs
autonomous: false

must_haves:
  truths:
    - "Modal popup appears when adaptive trigger fires"
    - "User can approve or cancel the adaptive action"
    - "Visual preview shows zoom target region on plot"
  artifacts:
    - path: "crates/daq-egui/src/widgets/adaptive_alert.rs"
      provides: "Modal dialog for trigger notifications"
      exports: ["AdaptiveAlert", "show_adaptive_alert"]
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Alert integration with execution state"
      contains: "adaptive_trigger_fired"
  key_links:
    - from: "crates/daq-egui/src/widgets/adaptive_alert.rs"
      to: "egui::Modal"
      via: "egui native modal container"
      pattern: "Modal::new"
---

<objective>
Implement adaptive trigger alert UI with modal confirmation dialog.

Purpose: When an adaptive scan detects a trigger (peak found, threshold crossed), the user needs notification and optional approval before the action executes.

Output: Modal alert with action details and approve/cancel buttons
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-scans/08-05-SUMMARY.md
@.planning/phases/08-advanced-scans/08-RESEARCH.md
@crates/daq-egui/src/panels/experiment_designer.rs
@crates/daq-egui/src/widgets/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdaptiveAlert widget using egui Modal</name>
  <files>crates/daq-egui/src/widgets/adaptive_alert.rs, crates/daq-egui/src/widgets/mod.rs</files>
  <action>
Create adaptive_alert.rs widget for trigger notifications:

1. **Alert data struct**:
```rust
//! Adaptive scan alert modal dialog.
//!
//! Shows trigger detection results and allows user to approve or cancel
//! the planned adaptive action.

use egui::{Color32, Id, Modal, RichText};
use crate::graph::nodes::AdaptiveAction;
use crate::graph::adaptive::DetectedPeak;

/// Data for an adaptive trigger alert.
#[derive(Clone, Debug)]
pub struct AdaptiveAlertData {
    /// Unique ID for this alert instance
    pub id: String,
    /// Which trigger condition(s) fired
    pub trigger_description: String,
    /// Detected peak information (if peak detection)
    pub peak: Option<DetectedPeak>,
    /// Action that will be taken
    pub action: AdaptiveAction,
    /// Whether user approval is required
    pub requires_approval: bool,
}

/// Response from the alert dialog.
#[derive(Clone, Debug, PartialEq)]
pub enum AdaptiveAlertResponse {
    /// User approved the action
    Approved,
    /// User cancelled the action
    Cancelled,
    /// Dialog still open (no response yet)
    Pending,
}
```

2. **show_adaptive_alert function**:
```rust
/// Show an adaptive trigger alert modal.
///
/// # Arguments
/// * `ctx` - egui context
/// * `data` - Alert data to display
///
/// # Returns
/// User response (Pending while dialog is open)
pub fn show_adaptive_alert(
    ctx: &egui::Context,
    data: &AdaptiveAlertData,
) -> AdaptiveAlertResponse {
    let mut response = AdaptiveAlertResponse::Pending;

    let modal = Modal::new(Id::new(&data.id))
        .backdrop_color(Color32::from_black_alpha(150));

    modal.show(ctx, |ui| {
        // Header with icon
        ui.horizontal(|ui| {
            ui.label(RichText::new("ðŸ”").size(24.0));
            ui.heading("Trigger Detected!");
        });

        ui.separator();
        ui.add_space(8.0);

        // Trigger description
        ui.label(&data.trigger_description);

        // Peak details if available
        if let Some(ref peak) = data.peak {
            ui.add_space(4.0);
            ui.horizontal(|ui| {
                ui.label("Peak height:");
                ui.label(RichText::new(format!("{:.2}", peak.height)).strong());
            });
            if let Some(pos) = peak.position {
                ui.horizontal(|ui| {
                    ui.label("Position:");
                    ui.label(RichText::new(format!("{:.4}", pos)).strong());
                });
            }
        }

        ui.add_space(12.0);

        // Action description
        let action_text = match data.action {
            AdaptiveAction::Zoom2x => "Zoom 2x and rescan region",
            AdaptiveAction::Zoom4x => "Zoom 4x and rescan region",
            AdaptiveAction::MoveToPeak => "Move actuator to peak position",
            AdaptiveAction::AcquireAtPeak => "Acquire data at peak position",
            AdaptiveAction::MarkAndContinue => "Mark location and continue",
        };

        ui.horizontal(|ui| {
            ui.label("Action:");
            ui.label(RichText::new(action_text).italics());
        });

        ui.add_space(16.0);

        // Approval buttons
        if data.requires_approval {
            ui.horizontal(|ui| {
                if ui.button(RichText::new("âœ“ Continue").color(Color32::GREEN)).clicked() {
                    response = AdaptiveAlertResponse::Approved;
                }
                if ui.button(RichText::new("âœ— Cancel").color(Color32::RED)).clicked() {
                    response = AdaptiveAlertResponse::Cancelled;
                }
            });
        } else {
            // Auto-proceed countdown (3 seconds)
            ui.label(RichText::new("Proceeding automatically...").weak());
            if ui.button("Cancel").clicked() {
                response = AdaptiveAlertResponse::Cancelled;
            }
        }
    });

    response
}
```

3. **Export in mod.rs**:
```rust
mod adaptive_alert;
pub use adaptive_alert::{AdaptiveAlertData, AdaptiveAlertResponse, show_adaptive_alert};
```
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>AdaptiveAlert widget using egui native Modal</done>
</task>

<task type="auto">
  <name>Task 2: Integrate adaptive alert into ExperimentDesignerPanel</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add adaptive alert handling to the experiment designer:

1. **Add state fields** to ExperimentDesignerPanel:
```rust
/// Active adaptive alert (if any)
adaptive_alert: Option<AdaptiveAlertData>,
/// Timestamp when auto-proceed should trigger (for non-approval alerts)
adaptive_alert_auto_proceed_at: Option<std::time::Instant>,
```

Initialize both to `None` in Default impl.

2. **Add alert display in update() method**:

In the main UI rendering, after existing panel content but before the frame ends:

```rust
// Show adaptive alert modal if present
if let Some(ref alert_data) = self.adaptive_alert {
    let response = show_adaptive_alert(ctx, alert_data);

    match response {
        AdaptiveAlertResponse::Approved => {
            // Resume execution with approved action
            self.confirm_adaptive_action();
            self.adaptive_alert = None;
        }
        AdaptiveAlertResponse::Cancelled => {
            // Cancel adaptive action and abort or continue
            self.cancel_adaptive_action();
            self.adaptive_alert = None;
        }
        AdaptiveAlertResponse::Pending => {
            // Check auto-proceed timeout for non-approval alerts
            if let Some(auto_time) = self.adaptive_alert_auto_proceed_at {
                if std::time::Instant::now() >= auto_time {
                    self.confirm_adaptive_action();
                    self.adaptive_alert = None;
                    self.adaptive_alert_auto_proceed_at = None;
                }
            }
        }
    }
}
```

3. **Add helper methods**:
```rust
impl ExperimentDesignerPanel {
    /// Show an adaptive trigger alert.
    fn show_adaptive_trigger_alert(&mut self, data: AdaptiveAlertData) {
        if !data.requires_approval {
            // Auto-proceed after 3 seconds
            self.adaptive_alert_auto_proceed_at =
                Some(std::time::Instant::now() + std::time::Duration::from_secs(3));
        }
        self.adaptive_alert = Some(data);
    }

    /// Confirm adaptive action and resume execution.
    fn confirm_adaptive_action(&mut self) {
        // TODO: Send signal to RunEngine to proceed with adaptive action
        tracing::info!("Adaptive action approved");
    }

    /// Cancel adaptive action.
    fn cancel_adaptive_action(&mut self) {
        // TODO: Send signal to RunEngine to skip adaptive action
        // May need to abort scan or continue without action
        tracing::info!("Adaptive action cancelled");
    }
}
```

4. **Hook into execution state updates**:

When processing checkpoint labels that indicate trigger evaluation, check if trigger fired and show alert:

```rust
// In process_execution_action or similar
if checkpoint_label.contains("_approval_required") {
    // Parse trigger info from execution state
    // For now, create placeholder alert
    self.show_adaptive_trigger_alert(AdaptiveAlertData {
        id: format!("trigger_{}", checkpoint_label),
        trigger_description: "Trigger condition met".to_string(),
        peak: None, // Would come from RunEngine
        action: AdaptiveAction::Zoom2x, // Would come from node config
        requires_approval: true,
    });
}
```
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>Adaptive alert integrated into experiment execution flow</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Adaptive trigger alert modal dialog with egui Modal.

Features implemented:
- Modal popup showing trigger detection details
- Peak information display (height, position)
- Action description (Zoom 2x, Move to peak, etc.)
- Approve/Cancel buttons for user confirmation
- Auto-proceed with timeout for non-approval alerts
  </what-built>
  <how-to-verify>
1. Build and run the GUI:
   ```
   cargo build -p daq-egui
   cargo run -p daq-egui --bin rust-daq-gui
   ```

2. Open Experiment Designer panel

3. Create an AdaptiveScan node and configure:
   - Set a device for the scan
   - Add a threshold or peak detection trigger
   - Check "Require approval" checkbox
   - Set action to "Zoom 2x"

4. Note: Full trigger testing requires running a scan. For UI verification:
   - Manually trigger the alert by adding temporary test code:
     ```rust
     // In experiment_designer.rs, after panel render:
     if ui.button("Test Alert").clicked() {
         self.show_adaptive_trigger_alert(AdaptiveAlertData {
             id: "test".to_string(),
             trigger_description: "Peak detected in signal".to_string(),
             peak: Some(DetectedPeak { index: 42, height: 1234.5, position: Some(45.67) }),
             action: AdaptiveAction::Zoom2x,
             requires_approval: true,
         });
     }
     ```
   - Click "Test Alert" to verify modal appears
   - Modal should show:
     - "Trigger Detected!" heading
     - Peak height and position
     - Action description
     - Continue/Cancel buttons
   - Click "Continue" to dismiss (check log for "Adaptive action approved")
   - Click "Cancel" to dismiss (check log for "Adaptive action cancelled")
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `cargo build -p daq-egui`
2. Tests: `cargo test -p daq-egui`
3. Format/lint: `cargo fmt --all && cargo clippy -p daq-egui`
4. Human verification of modal dialog appearance and behavior
</verification>

<success_criteria>
- Modal popup appears with semi-transparent backdrop
- Peak detection shows height and position values
- Action description matches configured AdaptiveAction
- Continue button approves and dismisses modal
- Cancel button cancels and dismisses modal
- Auto-proceed works for non-approval triggers (3 second delay)
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-scans/08-07-SUMMARY.md`
</output>
