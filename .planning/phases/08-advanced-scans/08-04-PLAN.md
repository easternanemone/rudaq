---
phase: 08-advanced-scans
plan: 04
type: execute
wave: 2
depends_on: ["08-02"]
files_modified:
  - crates/daq-egui/src/graph/translation.rs
  - crates/daq-egui/src/graph/validation.rs
  - crates/daq-egui/src/graph/codegen.rs
autonomous: true

must_haves:
  truths:
    - "NestedScan translates to correct outer × inner iteration structure"
    - "Nested scan body nodes execute at each outer × inner point"
    - "Code generation produces readable nested for loops"
  artifacts:
    - path: "crates/daq-egui/src/graph/translation.rs"
      provides: "NestedScan translation to PlanCommands"
      contains: "NestedScan"
    - path: "crates/daq-egui/src/graph/codegen.rs"
      provides: "Rhai code generation for nested scans"
      contains: "NestedScan"
  key_links:
    - from: "crates/daq-egui/src/graph/translation.rs"
      to: "find_loop_body_nodes"
      via: "Reuses body pin traversal from Loop"
      pattern: "find_loop_body_nodes"
---

<objective>
Implement translation and code generation for NestedScan nodes.

Purpose: NestedScan nodes must translate to executable PlanCommands with correct outer × inner iteration ordering and proper handling of body nodes.

Output: NestedScan translation with dimensional checkpoints and Rhai code generation
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-scans/08-02-SUMMARY.md
@crates/daq-egui/src/graph/translation.rs
@crates/daq-egui/src/graph/validation.rs
@crates/daq-egui/src/graph/codegen.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NestedScan translation to PlanCommands</name>
  <files>crates/daq-egui/src/graph/translation.rs</files>
  <action>
Add NestedScan handling in translate_node_with_snarl() function:

1. **Match arm for NestedScan**:
```rust
ExperimentNode::NestedScan(config) => {
    // Get body nodes (reuse existing find_loop_body_nodes)
    let body_nodes = find_loop_body_nodes(node_id, snarl);

    // Add actuators to movers list
    if !config.outer.actuator.is_empty() {
        movers.push(config.outer.actuator.clone());
    }
    if !config.inner.actuator.is_empty() {
        movers.push(config.inner.actuator.clone());
    }

    // Calculate step sizes
    let outer_step = if config.outer.points > 1 {
        (config.outer.stop - config.outer.start) / (config.outer.points as f64 - 1.0)
    } else { 0.0 };

    let inner_step = if config.inner.points > 1 {
        (config.inner.stop - config.inner.start) / (config.inner.points as f64 - 1.0)
    } else { 0.0 };

    // Nested iteration: outer × inner
    for outer_idx in 0..config.outer.points {
        let outer_pos = config.outer.start + outer_step * outer_idx as f64;

        // Move outer actuator
        if !config.outer.actuator.is_empty() {
            commands.push(PlanCommand::MoveTo {
                device_id: config.outer.actuator.clone(),
                position: outer_pos,
            });
        }

        commands.push(PlanCommand::Checkpoint {
            label: format!("nested_{:?}_outer_{}_start", node_id, outer_idx),
        });

        for inner_idx in 0..config.inner.points {
            let inner_pos = config.inner.start + inner_step * inner_idx as f64;

            // Move inner actuator
            if !config.inner.actuator.is_empty() {
                commands.push(PlanCommand::MoveTo {
                    device_id: config.inner.actuator.clone(),
                    position: inner_pos,
                });
            }

            commands.push(PlanCommand::Checkpoint {
                label: format!("nested_{:?}_outer_{}_inner_{}",
                               node_id, outer_idx, inner_idx),
            });

            // Execute body nodes at this point
            for &body_node_id in &body_nodes {
                if let Some(body_node) = snarl.get_node(body_node_id) {
                    let (body_cmds, body_movers, body_detectors, body_events) =
                        translate_node_with_snarl(body_node, body_node_id, snarl);
                    commands.extend(body_cmds);
                    movers.extend(body_movers);
                    detectors.extend(body_detectors);
                    events += body_events;
                }
            }

            // Emit event with dimensional positions
            let mut positions = HashMap::new();
            if !config.outer.actuator.is_empty() {
                positions.insert(config.outer.actuator.clone(), outer_pos);
            }
            if !config.inner.actuator.is_empty() {
                positions.insert(config.inner.actuator.clone(), inner_pos);
            }
            commands.push(PlanCommand::EmitEvent {
                stream: "primary".to_string(),
                data: HashMap::new(),
                positions,
            });
            events += 1;
        }

        commands.push(PlanCommand::Checkpoint {
            label: format!("nested_{:?}_outer_{}_end", node_id, outer_idx),
        });
    }
}
```

2. **Update loop body detection**:
Ensure find_loop_body_nodes works for NestedScan (it should already if using same pin conventions).

If NestedScan uses different pin indices, add a helper or modify the function to handle both Loop and NestedScan node types.

3. **Skip body nodes in main traversal**:
Update the loop_body_set construction to include NestedScan:
```rust
if matches!(loop_node, ExperimentNode::Loop(..) | ExperimentNode::NestedScan(..)) {
    let body_nodes = find_loop_body_nodes(loop_id, snarl);
    loop_body_set.extend(body_nodes);
}
```
  </action>
  <verify>
Run: `cargo test -p daq-egui -- nested`
Should compile and pass any existing tests.
  </verify>
  <done>NestedScan translation with outer × inner iteration and body execution</done>
</task>

<task type="auto">
  <name>Task 2: Add NestedScan validation</name>
  <files>crates/daq-egui/src/graph/validation.rs</files>
  <action>
Add validation rules for NestedScan nodes in validation.rs:

1. **Validate NestedScan configuration**:
```rust
fn validate_nested_scan(config: &NestedScanConfig) -> Vec<String> {
    let mut errors = Vec::new();

    // Outer dimension validation
    if config.outer.actuator.is_empty() {
        errors.push("Outer scan: device not selected".to_string());
    }
    if config.outer.points == 0 {
        errors.push("Outer scan: points must be > 0".to_string());
    }
    if config.outer.dimension_name.is_empty() {
        errors.push("Outer scan: dimension name required".to_string());
    }

    // Inner dimension validation
    if config.inner.actuator.is_empty() {
        errors.push("Inner scan: device not selected".to_string());
    }
    if config.inner.points == 0 {
        errors.push("Inner scan: points must be > 0".to_string());
    }
    if config.inner.dimension_name.is_empty() {
        errors.push("Inner scan: dimension name required".to_string());
    }

    // Warn on same actuator for outer and inner (likely user error)
    if config.outer.actuator == config.inner.actuator
       && !config.outer.actuator.is_empty() {
        errors.push("Warning: outer and inner use same actuator".to_string());
    }

    errors
}
```

2. **Add to validate_node() function**:
```rust
ExperimentNode::NestedScan(config) => {
    errors.extend(validate_nested_scan(config));
}
```

3. **Nesting depth warning**:
If needed, add validation for deep nesting detection (when NestedScan is inside another loop).

4. **Back-edge validation**:
Ensure existing back-edge detection (from Phase 4) applies to NestedScan body as well. The body pin traversal logic should already handle this.
  </action>
  <verify>
Run: `cargo test -p daq-egui -- validation`
Should pass validation tests.
  </verify>
  <done>NestedScan validation rules for configuration and dimension names</done>
</task>

<task type="auto">
  <name>Task 3: Add NestedScan Rhai code generation</name>
  <files>crates/daq-egui/src/graph/codegen.rs</files>
  <action>
Add NestedScan handling in the code generation module:

1. **Add match arm in node_to_rhai() or equivalent function**:
```rust
ExperimentNode::NestedScan(config) => {
    let mut code = String::new();

    // Comment describing the nested scan
    code.push_str(&format!(
        "// Nested scan: {} ({}) × {} ({})\n",
        config.outer.dimension_name, config.outer.points,
        config.inner.dimension_name, config.inner.points
    ));

    // Outer loop
    let outer_var = sanitize_varname(&config.outer.dimension_name);
    let outer_step = if config.outer.points > 1 {
        (config.outer.stop - config.outer.start) / (config.outer.points as f64 - 1.0)
    } else { 0.0 };

    code.push_str(&format!(
        "for {outer}_idx in 0..{points} {{\n",
        outer = outer_var,
        points = config.outer.points
    ));
    code.push_str(&format!(
        "    let {outer}_pos = {start:.1} + {step:.4} * {outer}_idx;\n",
        outer = outer_var,
        start = config.outer.start,
        step = outer_step
    ));

    // Move outer actuator
    if !config.outer.actuator.is_empty() {
        code.push_str(&format!(
            "    move_to(\"{device}\", {outer}_pos);\n",
            device = config.outer.actuator,
            outer = outer_var
        ));
    }

    // Inner loop
    let inner_var = sanitize_varname(&config.inner.dimension_name);
    let inner_step = if config.inner.points > 1 {
        (config.inner.stop - config.inner.start) / (config.inner.points as f64 - 1.0)
    } else { 0.0 };

    code.push_str(&format!(
        "\n    for {inner}_idx in 0..{points} {{\n",
        inner = inner_var,
        points = config.inner.points
    ));
    code.push_str(&format!(
        "        let {inner}_pos = {start:.1} + {step:.4} * {inner}_idx;\n",
        inner = inner_var,
        start = config.inner.start,
        step = inner_step
    ));

    // Move inner actuator
    if !config.inner.actuator.is_empty() {
        code.push_str(&format!(
            "        move_to(\"{device}\", {inner}_pos);\n",
            device = config.inner.actuator,
            inner = inner_var
        ));
    }

    // TODO: Body nodes would be inserted here
    code.push_str("        // Body nodes execute here\n");
    code.push_str("        checkpoint();\n");

    code.push_str("    }\n"); // Close inner loop
    code.push_str("}\n"); // Close outer loop

    code
}
```

2. **Helper for variable name sanitization**:
```rust
fn sanitize_varname(name: &str) -> String {
    name.chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .to_lowercase()
}
```

3. **Ensure body nodes are included**:
If code generation handles body nodes separately (via graph traversal), ensure NestedScan body nodes are properly indented within the nested loops.
  </action>
  <verify>
Run: `cargo test -p daq-egui -- codegen`
Should pass code generation tests.
  </verify>
  <done>Rhai code generation with readable nested for loops</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `cargo build -p daq-egui`
2. Tests: `cargo test -p daq-egui`
3. Format/lint: `cargo fmt --all && cargo clippy -p daq-egui`
4. Integration: Create a simple NestedScan graph and verify:
   - Translation produces correct command count (outer × inner points)
   - Code preview shows nested for loops
   - Validation errors show for empty devices
</verification>

<success_criteria>
- NestedScan with 10 outer × 5 inner points produces 50 EmitEvent commands
- Body nodes execute at each outer × inner point
- Generated Rhai code shows nested for loops with proper indentation
- Validation catches missing device selections
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-scans/08-04-SUMMARY.md`
</output>
