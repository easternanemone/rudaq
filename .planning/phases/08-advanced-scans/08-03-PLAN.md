---
phase: 08-advanced-scans
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/Cargo.toml
  - crates/daq-egui/src/graph/nodes.rs
  - crates/daq-egui/src/widgets/property_inspector/adaptive_scan_panel.rs
  - crates/daq-egui/src/widgets/property_inspector/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can add AdaptiveScan node to graph from palette/context menu"
    - "User can configure trigger conditions (threshold, peak detection)"
    - "User can select predefined action from menu (Zoom 2x, Move to peak, etc.)"
  artifacts:
    - path: "crates/daq-egui/src/graph/nodes.rs"
      provides: "AdaptiveScan node variant and trigger configuration"
      contains: "AdaptiveScan"
    - path: "crates/daq-egui/src/widgets/property_inspector/adaptive_scan_panel.rs"
      provides: "UI panel for adaptive scan triggers and actions"
      exports: ["AdaptiveScanPanel"]
  key_links:
    - from: "crates/daq-egui/src/graph/nodes.rs"
      to: "TriggerCondition enum"
      via: "AdaptiveScanConfig triggers field"
      pattern: "TriggerCondition"
---

<objective>
Add AdaptiveScan node type for scans that adjust based on acquired data.

Purpose: Scientists need scans that automatically respond to data - detecting peaks and zooming in, crossing thresholds and triggering actions. This enables intelligent data acquisition workflows.

Output: AdaptiveScan node with trigger configuration and action menu
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-scans/08-CONTEXT.md
@.planning/phases/08-advanced-scans/08-RESEARCH.md
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/widgets/property_inspector/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add find_peaks dependency to daq-egui</name>
  <files>crates/daq-egui/Cargo.toml</files>
  <action>
Add the find_peaks crate for peak detection algorithms:

```toml
# Under [dependencies]
find_peaks = "0.1"
```

The find_peaks crate provides scipy-equivalent prominence-based peak filtering. This is used during translation/execution to evaluate adaptive triggers.

Do NOT modify any existing dependencies.
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>find_peaks dependency added for peak detection</done>
</task>

<task type="auto">
  <name>Task 2: Add AdaptiveScan node variant and config structs</name>
  <files>crates/daq-egui/src/graph/nodes.rs</files>
  <action>
Add AdaptiveScanConfig and related types to nodes.rs:

1. **TriggerCondition enum** for different trigger types:
```rust
/// Conditions that can trigger adaptive scan actions.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum TriggerCondition {
    /// Signal crosses a threshold
    Threshold {
        device_id: String,
        operator: ThresholdOp,
        value: f64,
    },
    /// Peak detected in signal
    PeakDetection {
        device_id: String,
        min_prominence: f64,
        min_height: Option<f64>,
    },
}

impl Default for TriggerCondition {
    fn default() -> Self {
        Self::Threshold {
            device_id: String::new(),
            operator: ThresholdOp::GreaterThan,
            value: 1000.0,
        }
    }
}
```

2. **AdaptiveAction enum** for predefined actions:
```rust
/// Actions to take when trigger fires.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Default)]
pub enum AdaptiveAction {
    /// Narrow range and increase resolution (2x)
    #[default]
    Zoom2x,
    /// Narrow range and increase resolution (4x)
    Zoom4x,
    /// Move actuator to detected peak position
    MoveToPeak,
    /// Trigger acquisition at peak position
    AcquireAtPeak,
    /// Record peak location but continue scan unchanged
    MarkAndContinue,
}
```

3. **TriggerLogic enum** for combining multiple triggers:
```rust
/// Logic for combining multiple trigger conditions.
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub enum TriggerLogic {
    #[default]
    Any,  // OR - fire if any trigger matches
    All,  // AND - fire only if all triggers match
}
```

4. **AdaptiveScanConfig struct**:
```rust
/// Configuration for AdaptiveScan node.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AdaptiveScanConfig {
    /// Base scan configuration
    pub scan: ScanDimension,
    /// Trigger conditions
    pub triggers: Vec<TriggerCondition>,
    /// How to combine multiple triggers
    pub trigger_logic: TriggerLogic,
    /// Action to take when triggered
    pub action: AdaptiveAction,
    /// Pause for user approval before action (default: false)
    pub require_approval: bool,
}

impl Default for AdaptiveScanConfig {
    fn default() -> Self {
        Self {
            scan: ScanDimension::default(),
            triggers: vec![TriggerCondition::default()],
            trigger_logic: TriggerLogic::Any,
            action: AdaptiveAction::Zoom2x,
            require_approval: false,
        }
    }
}
```

5. **Add ExperimentNode variant**:
```rust
/// Adaptive scan that responds to acquired data
AdaptiveScan(AdaptiveScanConfig),
```

6. **Update node_name() and add constructor**:
```rust
ExperimentNode::AdaptiveScan(..) => "Adaptive Scan",

pub fn default_adaptive_scan() -> Self {
    ExperimentNode::AdaptiveScan(AdaptiveScanConfig::default())
}
```

Note: Reuse ScanDimension from Plan 02 if it exists, or use the existing Scan parameters directly.
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>AdaptiveScan node variant with trigger conditions and action types</done>
</task>

<task type="auto">
  <name>Task 3: Create property inspector panel for AdaptiveScan</name>
  <files>crates/daq-egui/src/widgets/property_inspector/adaptive_scan_panel.rs, crates/daq-egui/src/widgets/property_inspector/mod.rs</files>
  <action>
Create adaptive_scan_panel.rs with UI for configuring adaptive scans:

1. **AdaptiveScanPanel struct**:
```rust
pub struct AdaptiveScanPanel;

impl AdaptiveScanPanel {
    pub fn show(
        ui: &mut egui::Ui,
        config: &mut AdaptiveScanConfig,
        device_ids: &[String],
    ) -> bool // returns true if modified
}
```

2. **UI layout with sections**:

**"Base Scan" collapsing header:**
- Device selector (actuator)
- Start/Stop/Points fields
- Dimension name

**"Triggers" collapsing header:**
- Trigger list with add/remove buttons
- For each trigger:
  - Type selector (Threshold/Peak Detection)
  - Threshold: device, operator, value
  - Peak: device, min_prominence, optional min_height
- Trigger logic selector (Any/All)

**"Action" section:**
- Action dropdown (ComboBox) with options:
  - "Zoom 2x"
  - "Zoom 4x"
  - "Move to Peak"
  - "Acquire at Peak"
  - "Mark and Continue"
- Checkbox: "Require approval before action"

3. **Helper for TriggerCondition UI**:
```rust
fn show_trigger_condition(
    ui: &mut egui::Ui,
    trigger: &mut TriggerCondition,
    device_ids: &[String],
    index: usize,
) -> (bool, bool) // (modified, should_remove)
```

4. **Export in mod.rs**:
```rust
mod adaptive_scan_panel;
pub use adaptive_scan_panel::AdaptiveScanPanel;
```

5. **Integrate into PropertyInspector**:
```rust
ExperimentNode::AdaptiveScan(ref mut config) => {
    modified = AdaptiveScanPanel::show(ui, config, device_ids);
}
```

6. **Add/Remove trigger buttons**:
- "+" button to add new TriggerCondition::default()
- "Ã—" button on each trigger to remove
- Minimum 1 trigger required (disable remove if only one)
  </action>
  <verify>
Run: `cargo check -p daq-egui`
Should compile without errors.
  </verify>
  <done>Property inspector panel for AdaptiveScan with trigger and action configuration</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `cargo build -p daq-egui`
2. Tests: `cargo test -p daq-egui`
3. Format/lint: `cargo fmt --all && cargo clippy -p daq-egui`
4. Serialization: Verify AdaptiveScan nodes serialize/deserialize correctly
</verification>

<success_criteria>
- AdaptiveScan node can be added to graph
- User can configure threshold and peak detection triggers
- User can select from predefined action menu (Zoom 2x, Move to peak, etc.)
- Multiple triggers can be combined with AND/OR logic
- Optional "require approval" checkbox for user confirmation
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-scans/08-03-SUMMARY.md`
</output>
