---
phase: 07-code-export-and-provenance
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
  - crates/daq-egui/src/panels/script_editor.rs
  - crates/daq-egui/src/panels/mod.rs
autonomous: false

must_haves:
  truths:
    - "User can export graph as .rhai file via Export button"
    - "User can eject to script editor mode"
    - "Script editor mode shows editable code without graph"
  artifacts:
    - path: "crates/daq-egui/src/panels/script_editor.rs"
      provides: "Editable script mode after eject"
      exports: ["ScriptEditorPanel"]
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "file dialog"
      via: "rfd save dialog"
      pattern: "FileDialog::new"
    - from: "crates/daq-egui/src/panels/script_editor.rs"
      to: "crates/daq-egui/src/graph/codegen.rs"
      via: "initial code from graph"
      pattern: "graph_to_rhai_script"
---

<objective>
Add export functionality and script editor mode for power users.

Purpose: Satisfies CODE-02 (export as standalone Rhai file) and CODE-03 (switch to script editor mode). Power users can export their visual experiment to a script file for version control, sharing, or further customization.

Output: Export button in toolbar, ScriptEditorPanel for "ejected" mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-export-and-provenance/07-RESEARCH.md

# Prior plan output needed
@.planning/phases/07-code-export-and-provenance/07-01-SUMMARY.md

# Existing infrastructure
@crates/daq-egui/src/panels/experiment_designer.rs
@crates/daq-egui/src/graph/codegen.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Export Rhai button with file dialog</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
1. Add "Export Rhai..." button in toolbar (after Code toggle):
   ```rust
   if ui.button("Export Rhai...")
       .on_hover_text("Export as standalone Rhai script file (CODE-02)")
       .clicked()
   {
       self.export_rhai_dialog();
   }
   ```

2. Implement `export_rhai_dialog()` method:
   ```rust
   fn export_rhai_dialog(&mut self) {
       use rfd::FileDialog;
       use crate::graph::graph_to_rhai_script;

       // Generate code first
       let source_name = self.current_file
           .as_ref()
           .and_then(|p| p.file_name())
           .map(|n| n.to_string_lossy().to_string());
       let code = graph_to_rhai_script(&self.snarl, source_name.as_deref());

       // Suggest filename based on current graph file
       let suggested_name = self.current_file
           .as_ref()
           .and_then(|p| p.file_stem())
           .map(|s| format!("{}.rhai", s.to_string_lossy()))
           .unwrap_or_else(|| "experiment.rhai".to_string());

       // Open save dialog
       if let Some(path) = FileDialog::new()
           .add_filter("Rhai Script", &["rhai"])
           .set_file_name(&suggested_name)
           .save_file()
       {
           match std::fs::write(&path, &code) {
               Ok(()) => {
                   self.set_status(format!("Exported to {}", path.display()));
               }
               Err(e) => {
                   self.set_status(format!("Export failed: {}", e));
               }
           }
       }
   }
   ```

3. Add helper method `set_status()` if not already present:
   ```rust
   fn set_status(&mut self, message: String) {
       self.status_message = Some((message, std::time::Instant::now()));
   }
   ```
  </action>
  <verify>
`cargo build -p daq-egui` compiles. Run GUI, add nodes, click "Export Rhai...", verify file dialog opens with .rhai filter.
  </verify>
  <done>
Export button opens file dialog with .rhai filter. Generated code written to selected file. Status message shown on success/failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ScriptEditorPanel for ejected mode</name>
  <files>
    crates/daq-egui/src/panels/script_editor.rs
    crates/daq-egui/src/panels/mod.rs
  </files>
  <action>
1. Create `crates/daq-egui/src/panels/script_editor.rs`:
   ```rust
   //! Script editor panel for editing Rhai scripts directly.
   //!
   //! This panel is used after "ejecting" from the visual graph editor.
   //! Changes to the script do NOT sync back to the graph (one-way export).

   use egui_code_editor::{CodeEditor, ColorTheme, Syntax};
   use rfd::FileDialog;

   /// Panel for editing Rhai scripts directly (ejected from visual mode).
   pub struct ScriptEditorPanel {
       /// Script content
       code: String,
       /// Current file path (if saved)
       file_path: Option<std::path::PathBuf>,
       /// Color theme
       theme: ColorTheme,
       /// Whether content has unsaved changes
       dirty: bool,
       /// Status message
       status: Option<String>,
   }

   impl ScriptEditorPanel {
       /// Create new panel with initial code from graph
       pub fn from_graph_code(code: String, source_graph: Option<std::path::PathBuf>) -> Self {
           Self {
               code,
               file_path: None, // New script, not saved yet
               theme: ColorTheme::GRUVBOX_DARK,
               dirty: true, // Start as dirty since it's unsaved
               status: source_graph.map(|p| {
                   format!("Ejected from {}", p.display())
               }),
           }
       }

       pub fn ui(&mut self, ui: &mut egui::Ui) {
           // Toolbar
           ui.horizontal(|ui| {
               ui.heading("Script Editor");

               ui.separator();

               if ui.button("Save").on_hover_text("Ctrl+S").clicked() {
                   self.save();
               }

               if ui.button("Save As...").clicked() {
                   self.save_as();
               }

               if ui.button("Run").on_hover_text("Execute this script").clicked() {
                   // TODO: Connect to scripting engine execution
                   self.status = Some("Run not yet implemented".to_string());
               }

               ui.separator();

               // Theme selector
               egui::ComboBox::from_label("Theme")
                   .selected_text(self.theme_name())
                   .show_ui(ui, |ui| {
                       ui.selectable_value(&mut self.theme, ColorTheme::GRUVBOX_DARK, "Gruvbox Dark");
                       ui.selectable_value(&mut self.theme, ColorTheme::GRUVBOX, "Gruvbox Light");
                       ui.selectable_value(&mut self.theme, ColorTheme::AURA_DARK, "Aura Dark");
                   });

               ui.separator();

               // File info
               if let Some(path) = &self.file_path {
                   let dirty_marker = if self.dirty { "*" } else { "" };
                   ui.label(format!("{}{}", path.file_name().unwrap_or_default().to_string_lossy(), dirty_marker));
               } else {
                   ui.label("Unsaved*");
               }
           });

           // Status message
           if let Some(status) = &self.status {
               ui.label(status);
           }

           ui.separator();

           // Code editor (editable)
           let response = CodeEditor::default()
               .id_source("script_editor")
               .with_rows(40)
               .with_fontsize(13.0)
               .with_theme(self.theme)
               .with_syntax(Syntax::rust())
               .with_numlines(true)
               .show(ui, &mut self.code);

           // Track dirty state
           if response.response.changed() {
               self.dirty = true;
           }
       }

       fn save(&mut self) {
           if let Some(path) = &self.file_path {
               match std::fs::write(path, &self.code) {
                   Ok(()) => {
                       self.dirty = false;
                       self.status = Some(format!("Saved to {}", path.display()));
                   }
                   Err(e) => {
                       self.status = Some(format!("Save failed: {}", e));
                   }
               }
           } else {
               self.save_as();
           }
       }

       fn save_as(&mut self) {
           if let Some(path) = FileDialog::new()
               .add_filter("Rhai Script", &["rhai"])
               .set_file_name("script.rhai")
               .save_file()
           {
               self.file_path = Some(path.clone());
               self.save();
           }
       }

       fn theme_name(&self) -> &'static str {
           match self.theme {
               ColorTheme::GRUVBOX_DARK => "Gruvbox Dark",
               ColorTheme::GRUVBOX => "Gruvbox Light",
               ColorTheme::AURA_DARK => "Aura Dark",
               _ => "Custom",
           }
       }
   }
   ```

2. Add to `crates/daq-egui/src/panels/mod.rs`:
   ```rust
   mod script_editor;
   pub use script_editor::ScriptEditorPanel;
   ```
  </action>
  <verify>
`cargo check -p daq-egui` compiles without errors.
  </verify>
  <done>
ScriptEditorPanel created with editable code, save/save-as functionality, theme selection. Ready for integration with eject flow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Eject button and mode switching in ExperimentDesignerPanel</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
1. Add "Eject to Script" button in toolbar:
   ```rust
   if ui.button("Eject to Script")
       .on_hover_text("Convert to editable script (one-way, cannot return to graph) (CODE-03)")
       .clicked()
   {
       self.show_eject_confirmation = true;
   }
   ```

2. Add confirmation state field:
   ```rust
   /// Whether to show eject confirmation dialog
   show_eject_confirmation: bool,
   /// Script editor panel (Some when ejected)
   script_editor: Option<ScriptEditorPanel>,
   ```

3. Render confirmation dialog:
   ```rust
   if self.show_eject_confirmation {
       egui::Window::new("Eject to Script Mode?")
           .collapsible(false)
           .resizable(false)
           .show(ui.ctx(), |ui| {
               ui.label("This will convert your visual graph to an editable Rhai script.");
               ui.label("");
               ui.label("WARNING: This is one-way. You cannot convert the script back to a visual graph.");
               ui.label("Your .expgraph file will remain unchanged.");
               ui.label("");

               ui.horizontal(|ui| {
                   if ui.button("Cancel").clicked() {
                       self.show_eject_confirmation = false;
                   }

                   if ui.button("Eject").clicked() {
                       self.eject_to_script();
                       self.show_eject_confirmation = false;
                   }
               });
           });
   }
   ```

4. Implement `eject_to_script()`:
   ```rust
   fn eject_to_script(&mut self) {
       use crate::graph::graph_to_rhai_script;
       use crate::panels::ScriptEditorPanel;

       let source_name = self.current_file
           .as_ref()
           .and_then(|p| p.file_name())
           .map(|n| n.to_string_lossy().to_string());
       let code = graph_to_rhai_script(&self.snarl, source_name.as_deref());

       self.script_editor = Some(ScriptEditorPanel::from_graph_code(
           code,
           self.current_file.clone(),
       ));
   }
   ```

5. Modify ui() to show either graph editor OR script editor:
   ```rust
   pub fn ui(&mut self, ui: &mut egui::Ui, client: Option<&mut DaqClient>, runtime: Option<&Runtime>) {
       // If ejected, show script editor instead
       if let Some(editor) = &mut self.script_editor {
           // Add "Return to Graph" button (creates new graph, loses script changes)
           ui.horizontal(|ui| {
               if ui.button("New Graph")
                   .on_hover_text("Start a new visual graph (script changes will be lost)")
                   .clicked()
               {
                   self.script_editor = None;
                   self.new_graph();
               }
           });
           ui.separator();
           editor.ui(ui);
           return;
       }

       // ... rest of existing graph editor UI ...
   }
   ```
  </action>
  <verify>
`cargo build -p daq-egui` compiles. Run GUI and verify:
1. "Eject to Script" button appears
2. Confirmation dialog warns about one-way conversion
3. After eject, script editor replaces graph editor
4. "New Graph" button returns to graph mode
  </verify>
  <done>
Eject flow implemented with confirmation dialog. Script editor mode replaces graph editor. "New Graph" button provides escape hatch.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete code export and script mode functionality:
- Live code preview panel (toggleable)
- Export to .rhai file
- Eject to script editor mode
  </what-built>
  <how-to-verify>
1. Run GUI: `cargo run -p daq-egui`
2. Open Experiment Designer tab
3. Add a Scan node (configure device: "stage_x", start: 0, stop: 100, points: 10)
4. Add an Acquire node (detector: "camera")
5. Connect them
6. Click "Show Code" - verify code preview appears on right
7. Verify code contains for-loop, move_abs, yield_event calls
8. Click "Copy" - paste somewhere to verify it worked
9. Click "Export Rhai..." - save as test.rhai
10. Verify test.rhai contains the generated code
11. Click "Eject to Script" - confirm dialog
12. Verify script editor mode with editable code
13. Make an edit, verify dirty indicator appears
14. Click "New Graph" to return to graph mode
  </how-to-verify>
  <resume-signal>Type "approved" if all steps work, or describe issues encountered</resume-signal>
</task>

</tasks>

<verification>
```bash
# Build
cargo build -p daq-egui

# Run tests
cargo test -p daq-egui

# Manual testing per checkpoint above
```
</verification>

<success_criteria>
- [ ] Export Rhai button opens file dialog
- [ ] Generated .rhai file is valid (proper syntax, comments)
- [ ] Eject button shows confirmation dialog
- [ ] Script editor mode shows editable code
- [ ] Script editor has save/save-as functionality
- [ ] New Graph button returns to graph mode
- [ ] Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/07-code-export-and-provenance/07-04-SUMMARY.md`
</output>
