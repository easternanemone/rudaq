---
phase: 05-live-visualization
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User sees live camera frames displayed in image panel during acquisition"
    - "User sees live line plots updating in plot panels during acquisition"
  artifacts:
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Camera and plot streaming wiring"
      contains: "frame_tx.try_send|data_tx.try_send"
  key_links:
    - from: "ExperimentDesignerPanel"
      to: "gRPC StreamFrames"
      via: "spawn streaming task that sends to frame_tx"
      pattern: "stream_frames.*frame_tx"
    - from: "ExperimentDesignerPanel"
      to: "gRPC StreamDocuments"
      via: "spawn streaming task that extracts Event data and sends to data_tx"
      pattern: "stream_documents.*data_tx"
---

<objective>
Wire camera frame streaming and document data extraction to LiveVisualizationPanel channels.

Purpose: Close the data flow gaps identified in Phase 5 verification - frame_tx and data_tx channels exist but are never used to send data to the LiveVisualizationPanel.

Output: Live camera frames and plot data flow from gRPC streams to visualization panel during experiment execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-live-visualization/05-04-SUMMARY.md
@.planning/phases/05-live-visualization/05-VERIFICATION.md

## Reference Patterns (existing working implementations)

### Camera streaming pattern (from image_viewer.rs):
```rust
// Lines 1548-1651: spawn async task that subscribes to gRPC StreamFrames
let stream = match client.stream_frames(&device_id, max_fps, quality).await {
    Ok(s) => s,
    Err(e) => { /* handle error */ return; }
};

// Loop over stream and send to channel
while let Some(result) = stream.next().await {
    match result {
        Some(Ok(frame_data)) => {
            let update = FrameUpdate::from(frame_data);
            match frame_tx.try_send(update) {
                Ok(()) => { /* success */ }
                Err(TrySendError::Full(_)) => { /* drop frame */ }
                Err(TrySendError::Disconnected(_)) => { break; }
            }
        }
        // ...
    }
}
```

### Document streaming pattern (from scan_builder.rs):
```rust
// Lines 440-460: spawn async task for document stream
match client.stream_documents(run_uid, vec![]).await {
    Ok(mut stream) => {
        while let Some(result) = stream.next().await {
            match result {
                Ok(doc) => {
                    // Process doc.payload for Event documents
                    if let Some(Payload::Event(event)) = doc.payload {
                        // Extract scalar values from event.data: HashMap<String, f64>
                        for (device_id, value) in event.data {
                            // Send to data_tx
                        }
                    }
                }
                // ...
            }
        }
    }
}
```

## Key Types

From live_visualization.rs:
- `FrameUpdate { device_id, width, height, data: Vec<u8>, frame_number, timestamp_ns }`
- `DataUpdate { device_id, value: f64, timestamp_secs: f64 }`
- `FrameUpdateSender = mpsc::SyncSender<FrameUpdate>`
- `DataUpdateSender = mpsc::SyncSender<DataUpdate>`

From daq_proto::daq:
- `Document { doc_type, payload: Option<Payload> }`
- `Payload::Event(EventDocument { data: HashMap<String, f64>, timestamps, ... })`
- `FrameData { device_id, width, height, data, frame_number, timestamp_ns, ... }`

## Current State

ExperimentDesignerPanel has:
- `frame_tx: Option<FrameUpdateSender>` (created in start_visualization, stored, never used)
- `data_tx: Option<DataUpdateSender>` (created in start_visualization, stored, never used)
- `extract_detectors()` returns `(Vec<String>, Vec<String>)` - camera IDs and plot IDs

Missing:
1. Async task to subscribe to StreamFrames for each camera and send FrameUpdates
2. Async task to subscribe to StreamDocuments and extract Event data for plots
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire camera streaming to frame_tx</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add camera streaming subscription that sends FrameUpdate to frame_tx.

1. Add new imports at top of file:
   - `use futures::StreamExt;`
   - `use tokio::sync::mpsc as async_mpsc;`
   - `use std::sync::mpsc::TrySendError;`

2. Add field to ExperimentDesignerPanel struct:
   - `camera_stream_tasks: Vec<tokio::task::JoinHandle<()>>` (for cleanup on stop)

3. In start_visualization(), after creating channels and panel, for each camera_id in cameras:
   ```rust
   // Clone senders for async task
   let frame_tx = self.frame_tx.clone();
   let client = client.clone();
   let camera_id = camera_id.clone();

   let handle = runtime.spawn(async move {
       let Some(frame_tx) = frame_tx else { return; };

       // Start stream (30 FPS preview quality for live viz)
       match client.stream_frames(&camera_id, 30, StreamQuality::Preview).await {
           Ok(mut stream) => {
               while let Some(result) = stream.next().await {
                   match result {
                       Ok(frame_data) => {
                           let update = FrameUpdate {
                               device_id: camera_id.clone(),
                               width: frame_data.width,
                               height: frame_data.height,
                               data: frame_data.data,
                               frame_number: frame_data.frame_number,
                               timestamp_ns: frame_data.timestamp_ns,
                           };
                           if frame_tx.try_send(update).is_err() {
                               // Channel full or closed - continue trying
                           }
                       }
                       Err(e) => {
                           tracing::warn!(device = %camera_id, error = %e, "Camera stream error");
                           break;
                       }
                   }
               }
           }
           Err(e) => {
               tracing::error!(device = %camera_id, error = %e, "Failed to start camera stream");
           }
       }
   });
   self.camera_stream_tasks.push(handle);
   ```

4. Update start_visualization signature to accept client and runtime:
   `fn start_visualization(&mut self, client: &DaqClient, runtime: &Runtime)`

5. Update callers of start_visualization() in run_experiment() to pass client and runtime.

6. In stop_visualization(), abort all camera stream tasks:
   ```rust
   for handle in self.camera_stream_tasks.drain(..) {
       handle.abort();
   }
   ```

7. Initialize camera_stream_tasks in Default impl.

Note: The frame_tx is std::sync::mpsc::SyncSender which is Sync+Send, safe to clone into async task.
  </action>
  <verify>
cargo check -p daq-egui 2>&1 | grep -E "^error" || echo "No errors"
rg "frame_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs
  </verify>
  <done>
Camera IDs extracted from graph spawn streaming tasks that send FrameUpdate to frame_tx channel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire document streaming to data_tx for plots</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add document streaming subscription that extracts scalar data and sends DataUpdate to data_tx.

1. Add field to ExperimentDesignerPanel struct:
   - `document_stream_task: Option<tokio::task::JoinHandle<()>>`

2. In start_visualization(), after camera streaming setup, add document stream for plots:
   ```rust
   if !plots.is_empty() {
       let data_tx = self.data_tx.clone();
       let client = client.clone();
       let plot_ids: Vec<String> = plots.clone();

       let handle = runtime.spawn(async move {
           let Some(data_tx) = data_tx else { return; };

           // Subscribe to all documents (filter events client-side)
           match client.stream_documents(None, vec![]).await {
               Ok(mut stream) => {
                   while let Some(result) = stream.next().await {
                       match result {
                           Ok(doc) => {
                               use daq_proto::daq::document::Payload;
                               if let Some(Payload::Event(event)) = doc.payload {
                                   // Extract values for configured plot devices
                                   let timestamp_secs = event.time_ns as f64 / 1_000_000_000.0;
                                   for plot_id in &plot_ids {
                                       if let Some(&value) = event.data.get(plot_id) {
                                           let update = DataUpdate {
                                               device_id: plot_id.clone(),
                                               value,
                                               timestamp_secs,
                                           };
                                           if data_tx.try_send(update).is_err() {
                                               // Channel full or closed
                                           }
                                       }
                                   }
                               }
                           }
                           Err(e) => {
                               tracing::warn!(error = %e, "Document stream error");
                               break;
                           }
                       }
                   }
               }
               Err(e) => {
                   tracing::error!(error = %e, "Failed to start document stream");
               }
           }
       });
       self.document_stream_task = Some(handle);
   }
   ```

3. In stop_visualization(), abort document stream task:
   ```rust
   if let Some(handle) = self.document_stream_task.take() {
       handle.abort();
   }
   ```

4. Initialize document_stream_task in Default impl as None.

5. Add imports for daq_proto types if not already present:
   - `use daq_proto::daq::document::Payload;` (may need at function level)
  </action>
  <verify>
cargo check -p daq-egui 2>&1 | grep -E "^error" || echo "No errors"
rg "data_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs
  </verify>
  <done>
Plot device IDs extracted from graph configure document stream that filters Event documents and sends DataUpdate to data_tx channel.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo check -p daq-egui` passes with no errors
2. `rg "frame_tx.*try_send|data_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs` shows both senders in use
3. The gaps identified in 05-VERIFICATION.md are closed:
   - frame_tx now wired to StreamFrames responses
   - data_tx now wired to Event document data extraction
</verification>

<success_criteria>
- Camera streaming tasks spawn for each camera detector and send FrameUpdate to frame_tx
- Document streaming task spawns for plot detectors and sends DataUpdate to data_tx
- Streaming tasks are properly aborted on stop_visualization()
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-live-visualization/05-05-SUMMARY.md`
</output>
