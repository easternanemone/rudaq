---
phase: 05-live-visualization
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true

must_haves:
  truths:
    - "Visualization panels spawn automatically when experiment execution starts"
    - "Detectors from experiment graph are registered with visualization panel"
    - "Visualization panel starts receiving updates when execution begins"
    - "Visualization panel stops updating when execution completes"
  artifacts:
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Integration of live visualization with experiment execution"
      contains: "LiveVisualizationPanel"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/panels/live_visualization.rs"
      via: "creates and manages LiveVisualizationPanel during execution"
      pattern: "visualization_panel"
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/graph/execution_state.rs"
      via: "starts/stops visualization based on execution state"
      pattern: "execution_state.*is_active"
---

<objective>
Integrate LiveVisualizationPanel with ExperimentDesignerPanel to automatically spawn visualization when experiments start.

Purpose: When a scientist runs an experiment from the graph editor, they should see live data without manual setup. The graph editor knows which detectors are in the experiment and can automatically configure visualization.

Output: ExperimentDesignerPanel creates and manages LiveVisualizationPanel during execution, extracting detectors from graph.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-live-visualization/05-CONTEXT.md
@.planning/phases/05-live-visualization/05-03-SUMMARY.md (LiveVisualizationPanel)

Key existing code:
- ExperimentDesignerPanel has execution_state tracking
- Snarl<ExperimentNode> contains the graph with Acquire nodes
- start_execution() and completion flow already exist
- ExperimentNode::Acquire contains detector device_id
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LiveVisualizationPanel field and detector extraction</name>
  <files>
    crates/daq-egui/src/panels/experiment_designer.rs
  </files>
  <action>
Modify ExperimentDesignerPanel:

1. **Add field for visualization panel:**
   ```rust
   use crate::panels::{LiveVisualizationPanel, DetectorConfig, frame_channel, data_channel};

   pub struct ExperimentDesignerPanel {
       // ... existing fields ...

       /// Live visualization panel (shown during execution)
       visualization_panel: Option<LiveVisualizationPanel>,
       /// Sender for frame updates (passed to streaming task)
       frame_tx: Option<mpsc::SyncSender<FrameUpdate>>,
       /// Sender for data updates (passed to document subscriber)
       data_tx: Option<mpsc::SyncSender<DataUpdate>>,
   }
   ```

2. **Update Default impl:**
   ```rust
   impl Default for ExperimentDesignerPanel {
       fn default() -> Self {
           // ... existing ...
           Self {
               // ... existing fields ...
               visualization_panel: None,
               frame_tx: None,
               data_tx: None,
           }
       }
   }
   ```

3. **Add helper to extract detectors from graph:**
   ```rust
   fn extract_detectors(&self) -> Vec<DetectorConfig> {
       let mut detectors = Vec::new();

       for (_, node) in self.snarl.iter() {
           match node {
               ExperimentNode::Acquire(config) => {
                   // Check if device_id looks like a camera (has "camera" in name)
                   // or treat as line plot detector
                   let device_id = &config.device_id;
                   if device_id.to_lowercase().contains("camera")
                       || device_id.to_lowercase().contains("pvcam")
                   {
                       detectors.push(DetectorConfig::Camera {
                           device_id: device_id.clone(),
                       });
                   } else {
                       detectors.push(DetectorConfig::Plot {
                           device_id: device_id.clone(),
                           label: device_id.clone(),
                       });
                   }
               }
               _ => {}
           }
       }

       // Deduplicate by device_id
       detectors.sort_by(|a, b| {
           let id_a = match a { DetectorConfig::Camera { device_id } | DetectorConfig::Plot { device_id, .. } => device_id };
           let id_b = match b { DetectorConfig::Camera { device_id } | DetectorConfig::Plot { device_id, .. } => device_id };
           id_a.cmp(id_b)
       });
       detectors.dedup_by(|a, b| {
           let id_a = match a { DetectorConfig::Camera { device_id } | DetectorConfig::Plot { device_id, .. } => device_id };
           let id_b = match b { DetectorConfig::Camera { device_id } | DetectorConfig::Plot { device_id, .. } => device_id };
           id_a == id_b
       });

       detectors
   }
   ```

4. **Add method to start visualization:**
   ```rust
   fn start_visualization(&mut self) {
       // Create channels
       let (frame_tx, frame_rx) = frame_channel();
       let (data_tx, data_rx) = data_channel();

       // Extract detectors from graph
       let detectors = self.extract_detectors();

       // Create and configure panel
       let mut panel = LiveVisualizationPanel::new();
       panel.set_frame_receiver(frame_rx);
       panel.set_data_receiver(data_rx);
       panel.configure_detectors(detectors);
       panel.start();

       self.visualization_panel = Some(panel);
       self.frame_tx = Some(frame_tx);
       self.data_tx = Some(data_tx);
   }
   ```

5. **Add method to stop visualization:**
   ```rust
   fn stop_visualization(&mut self) {
       if let Some(ref mut panel) = self.visualization_panel {
           panel.stop();
       }
       // Keep panel visible for viewing final state
       // Clear senders to stop feeding data
       self.frame_tx = None;
       self.data_tx = None;
   }
   ```
  </action>
  <verify>
    - `cargo check -p daq-egui` compiles without errors
    - New fields added to ExperimentDesignerPanel
    - extract_detectors() finds Acquire nodes in graph
  </verify>
  <done>
    - LiveVisualizationPanel field added
    - Channel fields for frame/data senders added
    - extract_detectors() extracts detector configs from graph
    - start_visualization() creates and configures panel
    - stop_visualization() stops panel updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate visualization lifecycle with execution</name>
  <files>
    crates/daq-egui/src/panels/experiment_designer.rs
  </files>
  <action>
1. **Modify execution start (in run_experiment or similar):**
   Find where execution starts (likely in handle_run_button or similar) and add:
   ```rust
   // After successful execution start
   self.start_visualization();
   ```

2. **Modify execution completion handling:**
   In poll_execution_actions() or similar, when ExecutionAction::Completed is received:
   ```rust
   ExecutionAction::Completed => {
       // ... existing completion handling ...
       self.stop_visualization();
   }
   ```

3. **Modify ui() method to show visualization panel:**
   Find the main ui() method and add visualization panel rendering when active:
   ```rust
   pub fn ui(&mut self, ui: &mut egui::Ui, client: Option<&mut DaqClient>, runtime: Option<&Runtime>) {
       // ... existing code ...

       // If visualization panel exists and execution is active, show in a collapsible section
       if let Some(ref mut viz_panel) = self.visualization_panel {
           if self.execution_state.is_active() || self.execution_state.engine_state == EngineStateLocal::Idle {
               ui.separator();
               egui::CollapsingHeader::new("Live Visualization")
                   .default_open(true)
                   .show(ui, |ui| {
                       viz_panel.show(ui, ui.ctx());
                   });
           }
       }

       // ... rest of existing code ...
   }
   ```

   Alternative: Show visualization in a separate split or window. For simplicity, start with collapsing header.

4. **Handle abort case:**
   When abort is triggered, also stop visualization:
   ```rust
   ExecutionAction::Error(_) => {
       // ... existing error handling ...
       self.stop_visualization();
   }
   ```

5. **Clear visualization on new execution:**
   At start of execution, clear old panel:
   ```rust
   fn start_visualization(&mut self) {
       // Clear any existing panel first
       self.visualization_panel = None;
       self.frame_tx = None;
       self.data_tx = None;

       // ... rest of start_visualization ...
   }
   ```

Note: Full integration with document streaming for real data updates requires connecting frame_tx/data_tx to the gRPC streaming task. For this plan, the infrastructure is in place; actual data flow integration may require coordination with how documents are processed during execution (likely in poll_execution_actions or document stream handling).
  </action>
  <verify>
    - `cargo check -p daq-egui` compiles without errors
    - Visualization starts when execution starts
    - Visualization stops when execution completes or errors
    - Visualization panel renders in UI during execution
  </verify>
  <done>
    - Visualization lifecycle tied to execution state
    - Panel shown in UI when execution active
    - Channels created for data flow (integration with actual streaming is infrastructure-ready)
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p daq-egui` compiles without errors
2. ExperimentDesignerPanel has visualization_panel field
3. Visualization starts/stops with execution lifecycle
4. Detectors extracted from Acquire nodes in graph
</verification>

<success_criteria>
- Visualization panels spawn automatically when experiment starts
- Detectors from experiment graph registered with visualization
- Visualization lifecycle tied to execution state
- Infrastructure ready for frame/data streaming (channels created)
</success_criteria>

<output>
After completion, create `.planning/phases/05-live-visualization/05-04-SUMMARY.md`
</output>
