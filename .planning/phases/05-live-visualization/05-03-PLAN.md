---
phase: 05-live-visualization
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - crates/daq-egui/src/panels/live_visualization.rs
  - crates/daq-egui/src/panels/mod.rs
autonomous: true

must_haves:
  truths:
    - "User sees live camera frames in image panel during acquisition"
    - "User sees live line plots updating in plot panels during acquisition"
    - "FPS status shows acquired vs displayed rates"
    - "Multiple detectors display simultaneously in grid layout"
  artifacts:
    - path: "crates/daq-egui/src/panels/live_visualization.rs"
      provides: "Live visualization panel integrating camera and plot display"
      exports: ["LiveVisualizationPanel"]
      min_lines: 200
  key_links:
    - from: "crates/daq-egui/src/panels/live_visualization.rs"
      to: "crates/daq-egui/src/panels/multi_detector_grid.rs"
      via: "uses MultiDetectorGrid for layout"
      pattern: "MultiDetectorGrid"
    - from: "crates/daq-egui/src/panels/live_visualization.rs"
      to: "crates/daq-egui/src/widgets/auto_scale_plot.rs"
      via: "uses AutoScalePlot for line plots"
      pattern: "AutoScalePlot"
---

<objective>
Create the main LiveVisualizationPanel that integrates camera frame display and line plots with FPS status, using MultiDetectorGrid for layout.

Purpose: Scientists need a unified panel showing all detector data during acquisition - camera frames via existing image_viewer patterns, line plots with auto-scale, and FPS indicators to understand update rates.

Output: `LiveVisualizationPanel` that receives frame/data updates and displays in grid layout with FPS status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-live-visualization/05-CONTEXT.md
@.planning/phases/05-live-visualization/05-RESEARCH.md
@.planning/phases/05-live-visualization/05-01-SUMMARY.md (AutoScalePlot)
@.planning/phases/05-live-visualization/05-02-SUMMARY.md (MultiDetectorGrid)

Key patterns from existing code:
- image_viewer.rs: FrameUpdate struct, texture management with .set()
- signal_plotter.rs: ObservableUpdate message passing
- Use mpsc channels for async frame/data delivery
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LiveVisualizationPanel with frame and plot state</name>
  <files>
    crates/daq-egui/src/panels/live_visualization.rs
    crates/daq-egui/src/panels/mod.rs
  </files>
  <action>
Create `live_visualization.rs` with:

1. **FpsTracker struct for measuring display FPS:**
   ```rust
   struct FpsTracker {
       frame_times: VecDeque<Instant>,  // Last N frame timestamps
       window_size: usize,               // How many frames to track
   }

   impl FpsTracker {
       fn new(window_size: usize) -> Self { ... }
       fn record_frame(&mut self) { ... }
       fn fps(&self) -> f64 {
           if self.frame_times.len() < 2 { return 0.0; }
           let elapsed = self.frame_times.back()?.duration_since(*self.frame_times.front()?);
           (self.frame_times.len() - 1) as f64 / elapsed.as_secs_f64()
       }
   }
   ```

2. **CameraState struct for per-camera state:**
   ```rust
   struct CameraState {
       device_id: String,
       texture: Option<egui::TextureHandle>,
       last_frame_number: u64,
       display_fps: FpsTracker,
       // From server metrics
       acquired_fps: f64,
       frames_dropped: u64,
       // Display settings (use existing Colormap from image_viewer)
       colormap: crate::panels::image_viewer::Colormap,
       auto_contrast: bool,
       display_min: f32,
       display_max: f32,
   }
   ```

3. **PlotState struct for per-plot state:**
   ```rust
   struct PlotState {
       device_id: String,
       label: String,
       data: VecDeque<[f64; 2]>,  // (x, y) points
       auto_scale: AutoScalePlot,
       max_points: usize,         // Ring buffer limit (e.g., 1000)
       display_fps: FpsTracker,
   }
   ```

4. **LiveVisualizationPanel struct:**
   ```rust
   pub struct LiveVisualizationPanel {
       cameras: HashMap<String, CameraState>,   // device_id -> state
       plots: HashMap<String, PlotState>,       // device_id -> state
       grid: MultiDetectorGrid,
       // Channels for receiving updates
       frame_rx: Option<mpsc::Receiver<FrameUpdate>>,
       data_rx: Option<mpsc::Receiver<DataUpdate>>,
       // Active state
       active: bool,  // True during acquisition
   }
   ```

5. **DataUpdate struct for plot data:**
   ```rust
   pub struct DataUpdate {
       pub device_id: String,
       pub x: f64,
       pub y: f64,
   }
   ```

6. **Channel creation helpers:**
   ```rust
   pub fn frame_channel() -> (mpsc::SyncSender<FrameUpdate>, mpsc::Receiver<FrameUpdate>) {
       mpsc::sync_channel(4)  // Small buffer, drop old frames
   }

   pub fn data_channel() -> (mpsc::SyncSender<DataUpdate>, mpsc::Receiver<DataUpdate>) {
       mpsc::sync_channel(1000)  // Larger buffer for scalar data
   }
   ```

7. **LiveVisualizationPanel methods:**
   - `new() -> Self`
   - `set_frame_receiver(&mut self, rx: mpsc::Receiver<FrameUpdate>)`
   - `set_data_receiver(&mut self, rx: mpsc::Receiver<DataUpdate>)`
   - `configure_detectors(&mut self, detectors: Vec<DetectorConfig>)` - sets up cameras/plots and rebuilds grid
   - `start(&mut self)` - marks active, clears old data
   - `stop(&mut self)` - marks inactive
   - `poll_updates(&mut self, ctx: &egui::Context)` - drains channels, updates state

8. **DetectorConfig enum:**
   ```rust
   pub enum DetectorConfig {
       Camera { device_id: String },
       Plot { device_id: String, label: String },
   }
   ```

Add to `panels/mod.rs`:
```rust
mod live_visualization;
pub use live_visualization::{LiveVisualizationPanel, DataUpdate, DetectorConfig, frame_channel, data_channel};
```

Note: Reuse FrameUpdate from image_viewer module (already public).
  </action>
  <verify>
    - `cargo check -p daq-egui` compiles without errors
    - File exists at `crates/daq-egui/src/panels/live_visualization.rs`
    - Module exported in `panels/mod.rs`
  </verify>
  <done>
    - LiveVisualizationPanel struct exists with camera and plot state
    - Channel-based update mechanism for frames and data
    - FpsTracker for measuring display FPS
    - Detector configuration API
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement show() method with grid rendering and FPS status</name>
  <files>
    crates/daq-egui/src/panels/live_visualization.rs
  </files>
  <action>
Add `show()` method to LiveVisualizationPanel:

```rust
pub fn show(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
    // 1. Poll for updates
    self.poll_updates(ctx);

    // 2. Status bar at top
    ui.horizontal(|ui| {
        if self.active {
            ui.label(egui::RichText::new("LIVE").color(egui::Color32::GREEN));
        } else {
            ui.label(egui::RichText::new("IDLE").color(egui::Color32::GRAY));
        }

        ui.separator();

        // Aggregate FPS info
        if let Some((device_id, cam)) = self.cameras.iter().next() {
            ui.label(format!(
                "{}: {:.0} acq / {:.0} disp FPS",
                device_id,
                cam.acquired_fps,
                cam.display_fps.fps()
            ));
            if cam.frames_dropped > 0 {
                ui.label(
                    egui::RichText::new(format!("({} dropped)", cam.frames_dropped))
                        .color(egui::Color32::YELLOW)
                );
            }
        }
    });

    ui.separator();

    // 3. Build detector panels for grid
    let mut panels = Vec::new();
    for (device_id, _) in &self.cameras {
        panels.push(DetectorPanel {
            detector_type: DetectorType::Camera { device_id: device_id.clone() },
            title: device_id.clone(),
        });
    }
    for (device_id, state) in &self.plots {
        panels.push(DetectorPanel {
            detector_type: DetectorType::LinePlot {
                device_id: device_id.clone(),
                label: state.label.clone(),
            },
            title: state.label.clone(),
        });
    }
    self.grid = MultiDetectorGrid::with_panels(panels);

    // 4. Render grid with panel content
    let cameras = &mut self.cameras;
    let plots = &mut self.plots;

    self.grid.show(ui, |ui, panel| {
        // Panel frame with title
        egui::Frame::dark_canvas(ui.style())
            .inner_margin(4.0)
            .show(ui, |ui| {
                ui.vertical(|ui| {
                    ui.label(&panel.title);
                    ui.separator();

                    match &panel.detector_type {
                        DetectorType::Camera { device_id } => {
                            if let Some(cam) = cameras.get_mut(device_id) {
                                render_camera_panel(ui, cam);
                            }
                        }
                        DetectorType::LinePlot { device_id, .. } => {
                            if let Some(plot) = plots.get_mut(device_id) {
                                render_plot_panel(ui, plot);
                            }
                        }
                    }
                });
            });
    });

    // 5. Request repaint if active (for live updates)
    if self.active {
        ctx.request_repaint_after(std::time::Duration::from_millis(33)); // ~30 FPS
    }
}
```

Add helper functions:

```rust
fn render_camera_panel(ui: &mut egui::Ui, cam: &mut CameraState) {
    let available = ui.available_size();
    if let Some(ref texture) = cam.texture {
        let size = texture.size_vec2();
        let scale = (available.x / size.x).min(available.y / size.y).min(1.0);
        let display_size = size * scale;
        ui.image((texture.id(), display_size));
    } else {
        ui.centered_and_justified(|ui| {
            ui.label("Waiting for frames...");
        });
    }
}

fn render_plot_panel(ui: &mut egui::Ui, plot: &mut PlotState) {
    let points: Vec<[f64; 2]> = plot.data.iter().copied().collect();

    // Update auto-scale bounds
    plot.auto_scale.update_bounds(&points);

    plot.auto_scale.show_with_controls(ui, "live_plot", |plot_ui| {
        let line = egui_plot::Line::new(
            plot.label.clone(),
            egui_plot::PlotPoints::from_iter(points.iter().copied())
        ).color(egui::Color32::from_rgb(100, 200, 100));
        plot_ui.line(line);
    });
}
```

Implement poll_updates():

```rust
fn poll_updates(&mut self, ctx: &egui::Context) {
    // Drain frame channel (take latest only)
    if let Some(ref rx) = self.frame_rx {
        let mut latest: Option<FrameUpdate> = None;
        while let Ok(frame) = rx.try_recv() {
            latest = Some(frame);
        }
        if let Some(frame) = latest {
            self.process_frame(frame, ctx);
        }
    }

    // Drain data channel
    if let Some(ref rx) = self.data_rx {
        while let Ok(data) = rx.try_recv() {
            self.process_data(data);
        }
    }
}

fn process_frame(&mut self, frame: FrameUpdate, ctx: &egui::Context) {
    let cam = self.cameras.entry(frame.device_id.clone()).or_insert_with(|| {
        CameraState::new(frame.device_id.clone())
    });

    // Update metrics from server
    if let Some(metrics) = &frame.metrics {
        cam.acquired_fps = metrics.current_fps;
        cam.frames_dropped = metrics.frames_dropped;
    }

    // Record display frame
    cam.display_fps.record_frame();

    // Convert to RGBA and update texture
    // (Simplified - production would use background thread like image_viewer)
    let rgba = convert_to_rgba(&frame, cam.colormap, cam.display_min, cam.display_max);
    let image = egui::ColorImage::from_rgba_unmultiplied(
        [frame.width as usize, frame.height as usize],
        &rgba
    );

    if let Some(ref mut tex) = cam.texture {
        tex.set(image, egui::TextureOptions::NEAREST);
    } else {
        cam.texture = Some(ctx.load_texture(
            format!("cam_{}", frame.device_id),
            image,
            egui::TextureOptions::NEAREST
        ));
    }
}

fn process_data(&mut self, data: DataUpdate) {
    if let Some(plot) = self.plots.get_mut(&data.device_id) {
        plot.data.push_back([data.x, data.y]);
        if plot.data.len() > plot.max_points {
            plot.data.pop_front();
        }
        plot.display_fps.record_frame();
    }
}
```

Add simple RGBA conversion (can be improved later with background thread):

```rust
fn convert_to_rgba(frame: &FrameUpdate, colormap: Colormap, min: f32, max: f32) -> Vec<u8> {
    let pixel_count = (frame.width * frame.height) as usize;
    let mut rgba = vec![0u8; pixel_count * 4];

    let range = if max > min { max - min } else { 1.0 };

    match frame.bit_depth {
        8 => {
            for (i, &pixel) in frame.data.iter().enumerate().take(pixel_count) {
                let normalized = ((pixel as f32 - min) / range).clamp(0.0, 1.0);
                let rgb = colormap.apply(normalized);
                rgba[i * 4] = rgb[0];
                rgba[i * 4 + 1] = rgb[1];
                rgba[i * 4 + 2] = rgb[2];
                rgba[i * 4 + 3] = 255;
            }
        }
        16 => {
            for i in 0..pixel_count.min(frame.data.len() / 2) {
                let pixel = u16::from_le_bytes([frame.data[i * 2], frame.data[i * 2 + 1]]);
                let normalized = ((pixel as f32 - min) / range).clamp(0.0, 1.0);
                let rgb = colormap.apply(normalized);
                rgba[i * 4] = rgb[0];
                rgba[i * 4 + 1] = rgb[1];
                rgba[i * 4 + 2] = rgb[2];
                rgba[i * 4 + 3] = 255;
            }
        }
        _ => {
            // Fallback: treat as 8-bit
            for (i, &pixel) in frame.data.iter().enumerate().take(pixel_count) {
                rgba[i * 4] = pixel;
                rgba[i * 4 + 1] = pixel;
                rgba[i * 4 + 2] = pixel;
                rgba[i * 4 + 3] = 255;
            }
        }
    }

    rgba
}
```

Import Colormap from image_viewer (make it pub if needed).
  </action>
  <verify>
    - `cargo check -p daq-egui` compiles without errors
    - show() method renders status bar with FPS
    - Grid renders camera and plot panels
  </verify>
  <done>
    - show() method renders full live visualization UI
    - FPS status bar shows acquired vs displayed rates
    - Camera panels display frames via texture
    - Plot panels use AutoScalePlot with grow-to-fit
    - poll_updates drains channels and processes data
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p daq-egui` compiles without errors
2. `LiveVisualizationPanel` exported from `daq_egui::panels`
3. Panel has show() method that renders grid with cameras and plots
4. FPS status displayed in toolbar
</verification>

<success_criteria>
- LiveVisualizationPanel integrates camera frame display and line plots
- FPS status shows acquired vs displayed rates with dropped frame count
- Uses MultiDetectorGrid for automatic layout
- Uses AutoScalePlot for line plot auto-scaling
- Channel-based update mechanism for async frame/data delivery
</success_criteria>

<output>
After completion, create `.planning/phases/05-live-visualization/05-03-SUMMARY.md`
</output>
