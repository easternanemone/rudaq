---
phase: 06-data-management
plan: 03
type: execute
wave: 2
depends_on: [06-02]
files_modified:
  - crates/daq-egui/src/panels/run_history.rs
  - crates/daq-storage/src/lib.rs
  - crates/daq-storage/src/hdf5_annotation.rs
autonomous: true

must_haves:
  truths:
    - User can add notes and tags to a run after it completes
    - User can edit existing notes/tags on past runs
    - Annotations persist to HDF5 file as attributes on start group
    - Annotations are visible in run history detail view
  artifacts:
    - path: "crates/daq-storage/src/hdf5_annotation.rs"
      provides: "HDF5 attribute annotation utilities"
      exports: ["add_run_annotation", "read_run_annotations"]
      min_lines: 60
    - path: "crates/daq-egui/src/panels/run_history.rs"
      provides: "Annotation editor UI in detail view"
      contains: "add_annotation"
  key_links:
    - from: "RunHistoryPanel annotation UI"
      to: "hdf5_annotation::add_run_annotation"
      via: "spawn_blocking for file I/O"
      pattern: "spawn_blocking.*add_run_annotation"
    - from: "HDF5 start group"
      to: "user_notes, tags attributes"
      via: "new_attr::<VarLenUnicode>()"
      pattern: "new_attr.*user_notes|tags"
---

<objective>
Enable post-acquisition annotation of experiment runs by storing user notes and tags as HDF5 attributes, completing DATA-03 requirement.

Purpose: Users often discover important context AFTER reviewing data (e.g., "sample degraded", "outlier due to power glitch"). This allows capturing that context and associating it with the run permanently.

Output: HDF5 annotation utilities in daq-storage and annotation UI in RunHistoryPanel's detail view.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/briansquires/code/rust-daq/.planning/PROJECT.md
@/Users/briansquires/code/rust-daq/.planning/ROADMAP.md
@/Users/briansquires/code/rust-daq/.planning/STATE.md
@/Users/briansquires/code/rust-daq/.planning/phases/06-data-management/06-RESEARCH.md

# Existing infrastructure
@/Users/briansquires/code/rust-daq/crates/daq-storage/src/document_writer.rs
@/Users/briansquires/code/rust-daq/crates/daq-egui/src/panels/run_history.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HDF5 annotation utilities module</name>
  <files>crates/daq-storage/src/hdf5_annotation.rs, crates/daq-storage/src/lib.rs</files>
  <action>
Create `hdf5_annotation.rs` module in daq-storage crate for HDF5 attribute manipulation (Pattern 2 from RESEARCH.md).

Implementation:
```rust
//! HDF5 Annotation - Post-acquisition metadata editing
//!
//! Provides utilities for adding user notes and tags to completed runs
//! by modifying HDF5 attributes on the start group.

use anyhow::{Result, Context};
use std::path::Path;

#[cfg(feature = "storage_hdf5")]
use hdf5::{File, types::VarLenUnicode};

/// Annotation data for a run
#[derive(Debug, Clone)]
pub struct RunAnnotation {
    pub notes: String,
    pub tags: Vec<String>,
}

/// Add or update user annotation on an existing HDF5 file
///
/// This writes `user_notes` and `tags` attributes to the `/start` group.
/// If attributes already exist, they are overwritten.
#[cfg(feature = "storage_hdf5")]
pub fn add_run_annotation(file_path: &Path, annotation: &RunAnnotation) -> Result<()> {
    let file = File::open_rw(file_path)
        .context("Failed to open HDF5 file for annotation")?;

    let start_group = file.group("start")
        .context("HDF5 file missing /start group")?;

    // Delete existing attributes if present (HDF5 doesn't support overwrite)
    let _ = start_group.attr("user_notes").and_then(|a| a.delete());
    let _ = start_group.attr("tags").and_then(|a| a.delete());
    let _ = start_group.attr("annotated_at_ns").and_then(|a| a.delete());

    // Write user notes
    if !annotation.notes.is_empty() {
        start_group.new_attr::<VarLenUnicode>()
            .create("user_notes")?
            .write_scalar(&annotation.notes.parse()?)?;
    }

    // Write tags as JSON array
    if !annotation.tags.is_empty() {
        let tags_json = serde_json::to_string(&annotation.tags)?;
        start_group.new_attr::<VarLenUnicode>()
            .create("tags")?
            .write_scalar(&tags_json.parse()?)?;
    }

    // Timestamp the annotation
    let now_ns = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_nanos() as u64;

    start_group.new_attr::<u64>()
        .create("annotated_at_ns")?
        .write_scalar(&now_ns)?;

    Ok(())
}

/// Read existing annotations from an HDF5 file
///
/// Returns None if no annotations exist, Some(RunAnnotation) if found.
#[cfg(feature = "storage_hdf5")]
pub fn read_run_annotations(file_path: &Path) -> Result<Option<RunAnnotation>> {
    let file = File::open(file_path)
        .context("Failed to open HDF5 file")?;

    let start_group = file.group("start")
        .context("HDF5 file missing /start group")?;

    let notes = start_group.attr("user_notes")
        .ok()
        .and_then(|attr| attr.read_scalar::<VarLenUnicode>().ok())
        .map(|s| s.to_string())
        .unwrap_or_default();

    let tags = start_group.attr("tags")
        .ok()
        .and_then(|attr| attr.read_scalar::<VarLenUnicode>().ok())
        .and_then(|s| serde_json::from_str::<Vec<String>>(&s).ok())
        .unwrap_or_default();

    if notes.is_empty() && tags.is_empty() {
        Ok(None)
    } else {
        Ok(Some(RunAnnotation { notes, tags }))
    }
}

// Mock implementations for non-HDF5 builds
#[cfg(not(feature = "storage_hdf5"))]
pub fn add_run_annotation(_file_path: &Path, _annotation: &RunAnnotation) -> Result<()> {
    anyhow::bail!("HDF5 storage feature not enabled")
}

#[cfg(not(feature = "storage_hdf5"))]
pub fn read_run_annotations(_file_path: &Path) -> Result<Option<RunAnnotation>> {
    Ok(None)
}
```

Add to lib.rs:
```rust
#[cfg(feature = "storage_hdf5")]
pub mod hdf5_annotation;
#[cfg(feature = "storage_hdf5")]
pub use hdf5_annotation::{RunAnnotation, add_run_annotation, read_run_annotations};
```

Add serde_json dependency if not already present (likely already exists for metadata serialization).
  </action>
  <verify>
cargo build -p daq-storage --features storage_hdf5
cargo clippy -p daq-storage --features storage_hdf5 -- -D warnings
cargo test -p daq-storage --features storage_hdf5 hdf5_annotation
  </verify>
  <done>hdf5_annotation module exists with add_run_annotation and read_run_annotations functions, compiles with storage_hdf5 feature</done>
</task>

<task type="auto">
  <name>Task 2: Add annotation UI to RunHistoryPanel detail view</name>
  <files>crates/daq-egui/src/panels/run_history.rs</files>
  <action>
Extend RunHistoryPanel to include annotation editing in the detail view.

Add fields to RunHistoryPanel struct:
```rust
pub struct RunHistoryPanel {
    // ... existing fields ...
    annotation_notes: String,
    annotation_tags: String,  // Comma-separated
    annotation_status: Option<String>,  // Success/error message
}
```

Update Default impl:
```rust
annotation_notes: String::new(),
annotation_tags: String::new(),
annotation_status: None,
```

In the detail view section (Task 3 from 06-02), AFTER the metadata grid and BEFORE the Copy buttons, add annotation editor:

```rust
ui.separator();
ui.heading("Annotations");

// Load existing annotations if not already loaded
// (Only load once per selection change)
// For now, use empty strings - will load in next step

ui.label("Notes:");
ui.text_edit_multiline(&mut self.annotation_notes)
    .desired_width(f32::INFINITY)
    .desired_rows(3);

ui.horizontal(|ui| {
    ui.label("Tags (comma-separated):");
    ui.text_edit_singleline(&mut self.annotation_tags);
});

if ui.button("ðŸ’¾ Save Annotations").clicked() {
    // Will implement save logic in next step
    self.annotation_status = Some("Saving...".to_string());
}

if let Some(status) = &self.annotation_status {
    ui.label(status);
}
```

Add PendingAction variant:
```rust
enum PendingAction {
    Refresh,
    SaveAnnotation { file_path: String },
    LoadAnnotation { file_path: String },
}
```

Add ActionResult variant:
```rust
enum ActionResult {
    Refresh(Result<Vec<daq_proto::daq::AcquisitionSummary>, String>),
    SaveAnnotation(Result<(), String>),
    LoadAnnotation(Result<Option<daq_storage::RunAnnotation>, String>),
}
```

When selected_run_idx changes, trigger LoadAnnotation:
```rust
// In ui() method, detect selection change
if let Some(idx) = self.selected_run_idx {
    if let Some(acq) = self.filtered_acquisitions.get(idx) {
        // Check if this is a new selection
        // Load annotations if selection changed (compare to previous idx)
        // For simplicity, always load on render if annotations empty
        if self.annotation_notes.is_empty() && self.annotation_tags.is_empty() {
            self.pending_action = Some(PendingAction::LoadAnnotation {
                file_path: acq.file_path.clone(),
            });
        }
    }
}
```

Update poll_async_results to handle new variants:
```rust
ActionResult::SaveAnnotation(result) => {
    self.action_in_flight -= 1;
    match result {
        Ok(()) => self.annotation_status = Some("Annotations saved âœ“".to_string()),
        Err(e) => self.annotation_status = Some(format!("Error: {}", e)),
    }
}

ActionResult::LoadAnnotation(result) => {
    self.action_in_flight -= 1;
    match result {
        Ok(Some(annotation)) => {
            self.annotation_notes = annotation.notes;
            self.annotation_tags = annotation.tags.join(", ");
            self.annotation_status = None;
        }
        Ok(None) => {
            // No existing annotations
            self.annotation_notes.clear();
            self.annotation_tags.clear();
            self.annotation_status = None;
        }
        Err(e) => {
            self.annotation_status = Some(format!("Load error: {}", e));
        }
    }
}
```
  </action>
  <verify>
cargo build -p daq-egui --features storage_hdf5
cargo clippy -p daq-egui --features storage_hdf5 -- -D warnings
  </verify>
  <done>RunHistoryPanel detail view shows annotation editor with notes and tags fields, ActionResult variants added</done>
</task>

<task type="auto">
  <name>Task 3: Implement async save/load annotation handlers</name>
  <files>crates/daq-egui/src/panels/run_history.rs</files>
  <action>
Implement save_annotation and load_annotation methods in RunHistoryPanel.

Add methods:
```rust
impl RunHistoryPanel {
    fn save_annotation(&mut self, file_path: String, runtime: &Runtime) {
        let notes = self.annotation_notes.clone();
        let tags = self.annotation_tags
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>();

        let tx = self.action_tx.clone();
        self.action_in_flight += 1;

        runtime.spawn(async move {
            let result = tokio::task::spawn_blocking(move || {
                use std::path::PathBuf;
                let path = PathBuf::from(file_path);
                let annotation = daq_storage::RunAnnotation { notes, tags };
                daq_storage::add_run_annotation(&path, &annotation)
            })
            .await
            .map_err(|e| e.to_string())
            .and_then(|r| r.map_err(|e| e.to_string()));

            let _ = tx.send(ActionResult::SaveAnnotation(result)).await;
        });
    }

    fn load_annotation(&mut self, file_path: String, runtime: &Runtime) {
        let tx = self.action_tx.clone();
        self.action_in_flight += 1;

        runtime.spawn(async move {
            let result = tokio::task::spawn_blocking(move || {
                use std::path::PathBuf;
                let path = PathBuf::from(file_path);
                daq_storage::read_run_annotations(&path)
            })
            .await
            .map_err(|e| e.to_string())
            .and_then(|r| r.map_err(|e| e.to_string()));

            let _ = tx.send(ActionResult::LoadAnnotation(result)).await;
        });
    }
}
```

Update execute_action to handle new actions:
```rust
fn execute_action(&mut self, action: PendingAction, runtime: &Runtime) {
    match action {
        PendingAction::Refresh => self.refresh(client, runtime),
        PendingAction::SaveAnnotation { file_path } => {
            self.save_annotation(file_path, runtime);
        }
        PendingAction::LoadAnnotation { file_path } => {
            self.load_annotation(file_path, runtime);
        }
    }
}
```

Update "Save Annotations" button click handler:
```rust
if ui.button("ðŸ’¾ Save Annotations").clicked() {
    if let Some(acq) = self.filtered_acquisitions.get(idx) {
        self.pending_action = Some(PendingAction::SaveAnnotation {
            file_path: acq.file_path.clone(),
        });
    }
}
```

Add `use daq_storage::{RunAnnotation, add_run_annotation, read_run_annotations};` imports (conditional on storage_hdf5 feature).

Note: Since daq-egui may not have direct dependency on daq-storage, add to Cargo.toml:
```toml
[dependencies]
daq-storage = { path = "../daq-storage", optional = true, features = ["storage_hdf5"] }

[features]
default = []
storage_hdf5 = ["daq-storage"]
```

Guard annotation code with `#[cfg(feature = "storage_hdf5")]` and provide no-op implementations otherwise.
  </action>
  <verify>
cargo build -p daq-egui --features storage_hdf5
cargo clippy -p daq-egui --features storage_hdf5 -- -D warnings
  </verify>
  <done>RunHistoryPanel can save and load annotations to/from HDF5 files via spawn_blocking, compiles without errors</done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
cargo build -p daq-storage --features storage_hdf5
cargo build -p daq-egui --features storage_hdf5
cargo clippy -p daq-storage --features storage_hdf5 -- -D warnings
cargo clippy -p daq-egui --features storage_hdf5 -- -D warnings
cargo test -p daq-storage --features storage_hdf5 hdf5_annotation
```

**Integration checks:**
1. hdf5_annotation module compiles with storage_hdf5 feature
2. add_run_annotation writes user_notes, tags, annotated_at_ns attributes to HDF5 /start group
3. read_run_annotations reads existing attributes from HDF5 file
4. RunHistoryPanel loads annotations when run selected
5. RunHistoryPanel saves annotations via spawn_blocking (non-blocking UI)

**Success criteria verification:**
- [ ] User can add notes and tags to completed run (Task 2)
- [ ] User can edit existing notes/tags (Task 2)
- [ ] Annotations persist to HDF5 file (Task 1)
- [ ] Annotations visible in detail view (Task 2-3)
</verification>

<success_criteria>
**Measurable completion:**
1. hdf5_annotation.rs module exists with add_run_annotation and read_run_annotations functions
2. RunHistoryPanel detail view shows annotation editor (notes multi-line, tags single-line)
3. Clicking "Save Annotations" button writes to HDF5 file asynchronously
4. Selecting different run loads existing annotations from HDF5
5. HDF5 files contain user_notes, tags, and annotated_at_ns attributes in /start group
6. No clippy warnings in modified files

**Observable behaviors:**
- User opens Run History, selects a run
- User enters "Sample showed signs of degradation at t=10min" in notes field
- User enters "degradation, outlier" in tags field
- User clicks "Save Annotations" button, sees "Annotations saved âœ“"
- User selects different run, then re-selects first run
- Notes and tags are still present (persisted to HDF5)
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-management/06-03-SUMMARY.md` following the summary template with:
- Frontmatter: phase, plan, subsystem (storage + ui), tags (hdf5, annotations, post-acquisition)
- Dependency graph: requires HDF5 storage feature, provides annotation persistence, affects run history browsing
- Tech stack: added HDF5 VarLenUnicode attributes, spawn_blocking for file I/O
- Key files: created (hdf5_annotation.rs), modified (run_history.rs, storage lib.rs)
- Decisions: Tags as comma-separated string vs structured list, HDF5 attributes vs separate database
</output>
