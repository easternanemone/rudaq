---
phase: 06-data-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/src/panels/run_history.rs
  - crates/daq-egui/src/panels/mod.rs
  - crates/daq-egui/src/app.rs
autonomous: true

must_haves:
  truths:
    - User can see list of past experiment runs with name, date, plan type, and sample count
    - User can filter runs by text search (searches name, metadata fields)
    - User can click on a run to view detailed metadata
    - Runs are sorted by date (newest first) by default
    - UI remains responsive with 100+ runs (uses gRPC summaries, not full HDF5 files)
  artifacts:
    - path: "crates/daq-egui/src/panels/run_history.rs"
      provides: "RunHistoryPanel with filterable table and detail view"
      exports: ["RunHistoryPanel"]
      min_lines: 200
    - path: "crates/daq-egui/src/app.rs"
      provides: "RunHistoryPanel added to app panels"
      contains: "RunHistoryPanel"
  key_links:
    - from: "RunHistoryPanel"
      to: "StorageService.ListAcquisitions"
      via: "client.list_acquisitions()"
      pattern: "list_acquisitions"
    - from: "RunHistoryPanel"
      to: "AcquisitionSummary metadata display"
      via: "egui_extras::TableBuilder"
      pattern: "TableBuilder.*header.*body"
---

<objective>
Build a run history browser that lets users view, search, and filter past experiment runs using the existing gRPC StorageService infrastructure.

Purpose: Enable DATA-04 (browse run history and view previous results). Users can find experiments by metadata, review past work, and select runs for comparison.

Output: A new RunHistoryPanel with efficient table-based browsing, text filtering, and detail view for run metadata.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/briansquires/code/rust-daq/.planning/PROJECT.md
@/Users/briansquires/code/rust-daq/.planning/ROADMAP.md
@/Users/briansquires/code/rust-daq/.planning/STATE.md
@/Users/briansquires/code/rust-daq/.planning/phases/06-data-management/06-RESEARCH.md

# Reference patterns
@/Users/briansquires/code/rust-daq/crates/daq-egui/src/panels/storage.rs
@/Users/briansquires/code/rust-daq/crates/daq-egui/src/client.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RunHistoryPanel with async acquisition loading</name>
  <files>crates/daq-egui/src/panels/run_history.rs, crates/daq-egui/src/panels/mod.rs</files>
  <action>
Create `RunHistoryPanel` following StoragePanel's async pattern (PendingAction + mpsc channels).

Structure:
```rust
use eframe::egui;
use tokio::runtime::Runtime;
use tokio::sync::mpsc;
use crate::client::DaqClient;
use crate::widgets::{offline_notice, OfflineContext};

enum PendingAction {
    Refresh,
}

enum ActionResult {
    Refresh(Result<Vec<daq_proto::daq::AcquisitionSummary>, String>),
}

pub struct RunHistoryPanel {
    acquisitions: Vec<daq_proto::daq::AcquisitionSummary>,
    filtered_acquisitions: Vec<daq_proto::daq::AcquisitionSummary>,
    search_query: String,
    selected_run_idx: Option<usize>,
    last_refresh: Option<std::time::Instant>,
    error: Option<String>,
    pending_action: Option<PendingAction>,
    action_tx: mpsc::Sender<ActionResult>,
    action_rx: mpsc::Receiver<ActionResult>,
    action_in_flight: usize,
}

impl Default for RunHistoryPanel {
    fn default() -> Self {
        let (action_tx, action_rx) = mpsc::channel(16);
        Self {
            acquisitions: Vec::new(),
            filtered_acquisitions: Vec::new(),
            search_query: String::new(),
            selected_run_idx: None,
            last_refresh: None,
            error: None,
            pending_action: None,
            action_tx,
            action_rx,
            action_in_flight: 0,
        }
    }
}
```

Implement `poll_async_results` (copy pattern from StoragePanel):
- Process ActionResult::Refresh
- Update acquisitions and filtered_acquisitions
- Set last_refresh timestamp
- Request repaint if action_in_flight > 0

Implement `refresh` method:
```rust
fn refresh(&mut self, client: Option<&mut DaqClient>, runtime: &Runtime) {
    let Some(client) = client else {
        self.error = Some("Not connected".to_string());
        return;
    };

    let mut client = client.clone();
    let tx = self.action_tx.clone();
    self.action_in_flight += 1;

    runtime.spawn(async move {
        let result = client.list_acquisitions().await.map_err(|e| e.to_string());
        let _ = tx.send(ActionResult::Refresh(result)).await;
    });
}
```

Add `pub mod run_history;` and `pub use run_history::RunHistoryPanel;` to panels/mod.rs.
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>RunHistoryPanel struct exists with async acquisition loading via gRPC, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement table view with search filtering</name>
  <files>crates/daq-egui/src/panels/run_history.rs</files>
  <action>
Implement `ui()` method using egui_extras::TableBuilder (Pattern 3 from RESEARCH.md).

Layout:
1. Heading "Run History"
2. Offline notice check (reuse from StoragePanel)
3. Refresh button + last refresh timestamp
4. Error display (if any)
5. Search bar:
```rust
ui.horizontal(|ui| {
    ui.label("Search:");
    if ui.text_edit_singleline(&mut self.search_query).changed() {
        self.apply_filter();
    }
    if ui.button("Clear").clicked() {
        self.search_query.clear();
        self.apply_filter();
    }
});
```

6. Table with columns: Run UID (8 chars), Date, Plan Type, Samples, Size (MB), Name
```rust
use egui_extras::{TableBuilder, Column};

TableBuilder::new(ui)
    .striped(true)
    .resizable(true)
    .cell_layout(egui::Layout::left_to_right(egui::Align::Center))
    .column(Column::auto().at_least(80.0))  // UID
    .column(Column::auto().at_least(140.0)) // Date
    .column(Column::auto().at_least(100.0)) // Plan Type
    .column(Column::auto().at_least(80.0))  // Samples
    .column(Column::auto().at_least(80.0))  // Size
    .column(Column::remainder())            // Name
    .header(20.0, |mut header| {
        header.col(|ui| { ui.strong("Run UID"); });
        header.col(|ui| { ui.strong("Date"); });
        header.col(|ui| { ui.strong("Plan"); });
        header.col(|ui| { ui.strong("Samples"); });
        header.col(|ui| { ui.strong("Size (MB)"); });
        header.col(|ui| { ui.strong("Name"); });
    })
    .body(|mut body| {
        for (idx, acq) in self.filtered_acquisitions.iter().enumerate() {
            body.row(18.0, |mut row| {
                let is_selected = self.selected_run_idx == Some(idx);

                row.col(|ui| {
                    if ui.selectable_label(is_selected, &acq.acquisition_id[..8.min(acq.acquisition_id.len())]).clicked() {
                        self.selected_run_idx = Some(idx);
                    }
                });
                row.col(|ui| { ui.label(format_timestamp(acq.created_at_ns)); });
                row.col(|ui| { ui.label(&acq.plan_type); });
                row.col(|ui| { ui.label(acq.sample_count.to_string()); });
                row.col(|ui| { ui.label(format!("{:.2}", acq.file_size_bytes as f64 / 1_000_000.0)); });
                row.col(|ui| { ui.label(&acq.name); });
            });
        }
    });
```

Implement `apply_filter()` method:
```rust
fn apply_filter(&mut self) {
    if self.search_query.is_empty() {
        self.filtered_acquisitions = self.acquisitions.clone();
    } else {
        let query_lower = self.search_query.to_lowercase();
        self.filtered_acquisitions = self.acquisitions.iter()
            .filter(|acq| {
                acq.name.to_lowercase().contains(&query_lower) ||
                acq.acquisition_id.to_lowercase().contains(&query_lower) ||
                acq.plan_type.to_lowercase().contains(&query_lower)
            })
            .cloned()
            .collect();
    }
    self.selected_run_idx = None;  // Clear selection when filter changes
}
```

Helper function for timestamp formatting (from RESEARCH.md):
```rust
fn format_timestamp(ns: u64) -> String {
    use chrono::{DateTime, Utc, TimeZone};
    let secs = ns / 1_000_000_000;
    Utc.timestamp_opt(secs as i64, 0)
        .unwrap()
        .format("%Y-%m-%d %H:%M:%S")
        .to_string()
}
```

Add `use chrono` (already in Cargo.toml).

Handle pending_action at end of ui():
```rust
if let Some(action) = self.pending_action.take() {
    match action {
        PendingAction::Refresh => self.refresh(client, runtime),
    }
}
```

Trigger initial refresh on first render:
```rust
if self.last_refresh.is_none() {
    self.pending_action = Some(PendingAction::Refresh);
}
```
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>RunHistoryPanel renders table with search filtering, selectable rows, and formatted timestamps</done>
</task>

<task type="auto">
  <name>Task 3: Add detail view panel for selected run</name>
  <files>crates/daq-egui/src/panels/run_history.rs</files>
  <action>
Add detail view section in `ui()` method AFTER the table, showing metadata for selected run.

After table rendering:
```rust
ui.separator();

if let Some(idx) = self.selected_run_idx {
    if let Some(acq) = self.filtered_acquisitions.get(idx) {
        ui.heading("Run Details");

        egui::Grid::new("run_details_grid")
            .num_columns(2)
            .spacing([40.0, 4.0])
            .striped(true)
            .show(ui, |ui| {
                ui.label("Run UID:");
                ui.label(&acq.acquisition_id);
                ui.end_row();

                ui.label("Name:");
                ui.label(&acq.name);
                ui.end_row();

                ui.label("Plan Type:");
                ui.label(&acq.plan_type);
                ui.end_row();

                ui.label("Created:");
                ui.label(format_timestamp(acq.created_at_ns));
                ui.end_row();

                ui.label("File Path:");
                ui.label(&acq.file_path);
                ui.end_row();

                ui.label("File Size:");
                ui.label(format!("{:.2} MB", acq.file_size_bytes as f64 / 1_000_000.0));
                ui.end_row();

                ui.label("Sample Count:");
                ui.label(acq.sample_count.to_string());
                ui.end_row();
            });

        // Metadata section (if available in AcquisitionSummary)
        // Note: Current AcquisitionSummary may not have metadata field
        // If it does, add:
        // ui.separator();
        // ui.heading("Metadata");
        // for (key, value) in &acq.metadata {
        //     ui.horizontal(|ui| {
        //         ui.label(format!("{}:", key));
        //         ui.label(value);
        //     });
        // }

        ui.horizontal(|ui| {
            if ui.button("Copy Run UID").clicked() {
                ui.output_mut(|o| o.copied_text = acq.acquisition_id.clone());
            }

            if ui.button("Copy File Path").clicked() {
                ui.output_mut(|o| o.copied_text = acq.file_path.clone());
            }
        });
    }
} else {
    ui.label("Select a run to view details");
}
```

Note: AcquisitionSummary from daq_proto may not include metadata field yet. If not present, add TODO comment:
```rust
// TODO: Display run metadata when AcquisitionSummary includes metadata field
// This will be populated from HDF5 attributes in future enhancement
```
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>RunHistoryPanel shows detail view with full run information when row selected</done>
</task>

<task type="auto">
  <name>Task 4: Integrate RunHistoryPanel into app</name>
  <files>crates/daq-egui/src/app.rs</files>
  <action>
Add RunHistoryPanel to app panels.

In DaqGuiApp struct (locate the panels section):
```rust
use crate::panels::RunHistoryPanel;

pub struct DaqGuiApp {
    // ... existing panels ...
    run_history_panel: RunHistoryPanel,
}
```

In `impl Default for DaqGuiApp`:
```rust
run_history_panel: RunHistoryPanel::default(),
```

In `update()` method, add tab to the main TabBar (locate the panel tabs, likely near StoragePanel):
```rust
tab_bar.add_tab(|ui| {
    ui.label("ðŸ“š Run History");
}, |ui| {
    self.run_history_panel.ui(ui, self.client.as_mut(), &self.runtime);
});
```

Place this tab adjacent to Storage panel for logical grouping (data management panels together).
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>RunHistoryPanel appears as "Run History" tab in main app, renders table and detail view</done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
cargo test -p daq-egui --lib run_history
```

**Integration checks:**
1. RunHistoryPanel compiles and integrates into app without errors
2. Async acquisition loading uses gRPC StorageService.ListAcquisitions
3. Table renders with egui_extras::TableBuilder
4. Search filtering updates filtered_acquisitions reactively
5. Detail view shows selected run metadata

**Success criteria verification:**
- [ ] User sees list of past runs with name, date, plan type, sample count (Task 2)
- [ ] User can filter runs by text search (Task 2)
- [ ] User can click run to view detailed metadata (Tasks 2-3)
- [ ] Runs sorted by date (AcquisitionSummary already sorted by gRPC)
- [ ] UI remains responsive (uses summaries, not full HDF5 files)
</verification>

<success_criteria>
**Measurable completion:**
1. RunHistoryPanel exists in panels/run_history.rs with ui() method
2. App shows "Run History" tab in main UI
3. Clicking "Refresh" button loads acquisitions via gRPC
4. Entering text in search bar filters visible runs
5. Clicking table row shows detail panel with run metadata
6. No clippy warnings in modified files

**Observable behaviors:**
- User opens "Run History" tab
- User sees table of past runs sorted by date (newest first)
- User types "calibration" in search, sees only matching runs
- User clicks a run, sees full metadata in detail panel
- User clicks "Copy Run UID" button, UID copied to clipboard
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-management/06-02-SUMMARY.md` following the summary template with:
- Frontmatter: phase, plan, subsystem (ui), tags (run-history, egui_extras, filtering)
- Dependency graph: requires StorageService.ListAcquisitions, provides run browsing UI, affects 06-04 (run comparison)
- Tech stack: added egui_extras::TableBuilder pattern, chrono timestamp formatting
- Key files: created (run_history.rs), modified (app.rs, panels/mod.rs)
- Decisions: Text search instead of structured query (Phase 6 scope), selectable table rows vs checkboxes
</output>
