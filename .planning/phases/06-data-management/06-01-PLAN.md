---
phase: 06-data-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/src/widgets/metadata_editor.rs
  - crates/daq-egui/src/widgets/mod.rs
  - crates/daq-egui/src/panels/scan_builder.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true

must_haves:
  truths:
    - User can enter sample ID, operator, purpose, and notes before starting experiment
    - User can add custom key-value metadata pairs (arbitrary fields)
    - Entered metadata appears in StartDoc and persists to HDF5 file
    - Common fields (sample, operator, purpose) are suggested but not required
  artifacts:
    - path: "crates/daq-egui/src/widgets/metadata_editor.rs"
      provides: "MetadataEditor widget with extensible key-value UI"
      exports: ["MetadataEditor"]
      min_lines: 100
    - path: "crates/daq-egui/src/panels/scan_builder.rs"
      provides: "MetadataEditor integration in scan builder"
      contains: "MetadataEditor"
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "MetadataEditor integration in experiment designer"
      contains: "MetadataEditor"
  key_links:
    - from: "MetadataEditor"
      to: "StartDoc.metadata HashMap"
      via: "to_metadata_map() method"
      pattern: "metadata\\.insert"
    - from: "ScanBuilderPanel"
      to: "QueuePlanRequest.metadata field"
      via: "metadata_editor.to_metadata_map()"
      pattern: "QueuePlanRequest.*metadata"
---

<objective>
Capture user-provided experiment metadata (sample ID, operator, purpose, notes, custom fields) and enrich StartDoc with this metadata for HDF5 persistence.

Purpose: Enable DATA-02 (metadata captured automatically) and DATA-03 partial (user can add notes/tags during experiment setup). This provides the foundation for run history browsing and comparison tools.

Output: A reusable MetadataEditor widget integrated into ScanBuilderPanel and ExperimentDesignerPanel, with metadata flowing through to StartDoc and HDF5 storage.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/briansquires/code/rust-daq/.planning/PROJECT.md
@/Users/briansquires/code/rust-daq/.planning/ROADMAP.md
@/Users/briansquires/code/rust-daq/.planning/STATE.md
@/Users/briansquires/code/rust-daq/.planning/phases/06-data-management/06-RESEARCH.md

# Existing infrastructure
@/Users/briansquires/code/rust-daq/crates/daq-core/src/experiment/document.rs
@/Users/briansquires/code/rust-daq/crates/daq-storage/src/document_writer.rs
@/Users/briansquires/code/rust-daq/crates/daq-egui/src/panels/scan_builder.rs
@/Users/briansquires/code/rust-daq/crates/daq-egui/src/panels/experiment_designer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetadataEditor widget with extensible key-value fields</name>
  <files>crates/daq-egui/src/widgets/metadata_editor.rs, crates/daq-egui/src/widgets/mod.rs</files>
  <action>
Create `MetadataEditor` widget following the patterns from 06-RESEARCH.md (Pattern 1: Metadata Capture During Execution).

Structure:
```rust
pub struct MetadataEditor {
    sample_id: String,
    operator: String,
    purpose: String,
    notes: String,
    tags: String,  // Comma-separated for simplicity
    custom_fields: Vec<(String, String)>,
}
```

UI layout:
- Common fields section: sample_id, operator, purpose (single-line text inputs)
- Notes field: multi-line text edit (TextEdit::multiline)
- Tags field: comma-separated input (single-line, hint: "calibration, test, baseline")
- Custom fields section: dynamic list of key-value pairs
- "+ Add Field" button to append new custom field row
- Delete button for each custom field row

Methods:
- `pub fn new() -> Self` - default constructor
- `pub fn ui(&mut self, ui: &mut egui::Ui)` - render widget
- `pub fn to_metadata_map(&self) -> HashMap<String, String>` - convert to StartDoc.metadata format
  - Include all common fields (even if empty, for consistency)
  - Parse tags into JSON array: `serde_json::to_string(&tags.split(',').map(|s| s.trim()).collect::<Vec<_>>())`
  - Include all custom fields with non-empty keys
- `pub fn is_empty(&self) -> bool` - check if any metadata entered

Add `pub mod metadata_editor;` and `pub use metadata_editor::MetadataEditor;` to widgets/mod.rs.

Reference implementation from RESEARCH.md section "Metadata Input Widget During Execution" but use separate tags field instead of embedding in custom fields.
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>MetadataEditor widget exists, compiles, and exports to_metadata_map() returning HashMap&lt;String, String&gt;</done>
</task>

<task type="auto">
  <name>Task 2: Integrate MetadataEditor into ScanBuilderPanel</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
Add MetadataEditor field to ScanBuilderPanel struct:
```rust
use crate::widgets::MetadataEditor;

pub struct ScanBuilderPanel {
    // ... existing fields ...
    metadata_editor: MetadataEditor,
}
```

In `impl Default`:
```rust
metadata_editor: MetadataEditor::new(),
```

In `ui()` method, add collapsible metadata section BEFORE the "Build & Run" button:
```rust
ui.separator();
egui::CollapsingHeader::new("Experiment Metadata (Optional)")
    .default_open(false)
    .show(ui, |ui| {
        self.metadata_editor.ui(ui);
    });
```

In the scan execution code (where QueuePlanRequest is created), enrich metadata:
```rust
// In 1D scan execution
let mut metadata = self.metadata_editor.to_metadata_map();
// Auto-add scan configuration to metadata for provenance
metadata.insert("scan_type".to_string(), "line_scan".to_string());
metadata.insert("actuator".to_string(), actuator_id.clone());
metadata.insert("detector".to_string(), detector_id.clone());

// In QueuePlanRequest construction
let request = QueuePlanRequest {
    // ... existing fields ...
    metadata,  // Pass metadata map
};
```

Repeat for 2D grid scan execution (scan_type = "grid_scan", add motor_x, motor_y).

Use existing `use std::collections::HashMap;` import.
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
# Verify UI renders (manual check in human verification)
  </verify>
  <done>ScanBuilderPanel shows collapsible metadata section, metadata map passed to QueuePlanRequest including auto-added scan config</done>
</task>

<task type="auto">
  <name>Task 3: Integrate MetadataEditor into ExperimentDesignerPanel</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add MetadataEditor field to ExperimentDesignerPanel struct:
```rust
use crate::widgets::MetadataEditor;

pub struct ExperimentDesignerPanel {
    // ... existing fields ...
    metadata_editor: MetadataEditor,
}
```

In `impl Default`:
```rust
metadata_editor: MetadataEditor::new(),
```

In `ui()` method, locate the execution controls area (Run/Pause/Resume buttons). Add metadata section in the right panel BEFORE execution controls:
```rust
egui::CollapsingHeader::new("Run Metadata (Optional)")
    .default_open(false)
    .show(ui, |ui| {
        self.metadata_editor.ui(ui);
    });
```

In `queue_plan_to_server()` method (around line 855 where TODO exists), when constructing QueuePlanRequest:
```rust
// Extract metadata from editor
let mut metadata = self.metadata_editor.to_metadata_map();
// Auto-add graph provenance
metadata.insert("graph_node_count".to_string(), self.graph.nodes.len().to_string());
metadata.insert("graph_file".to_string(),
    self.current_file.as_ref()
        .and_then(|p| p.file_name().and_then(|n| n.to_str()))
        .unwrap_or("unsaved")
        .to_string()
);

// In QueuePlanRequest
let request = QueuePlanRequest {
    plan: serde_json::to_string(&graph_plan)?,
    metadata,
    // ... other fields ...
};
```

Note: This addresses the TODO at line 855 mentioned in STATE.md blockers.
  </action>
  <verify>
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
  </verify>
  <done>ExperimentDesignerPanel shows metadata section, metadata passed to QueuePlanRequest with graph provenance auto-added</done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
cargo build -p daq-egui
cargo clippy -p daq-egui -- -D warnings
cargo test -p daq-egui --lib metadata_editor
```

**Integration checks:**
1. MetadataEditor widget compiles and exports to widgets module
2. ScanBuilderPanel and ExperimentDesignerPanel integrate MetadataEditor without errors
3. Metadata flows from UI -> to_metadata_map() -> QueuePlanRequest
4. Auto-added metadata (scan_type, actuator, graph info) enriches user metadata

**Success criteria verification:**
- [ ] User can enter sample ID, operator, purpose, notes (Task 1)
- [ ] User can add custom key-value pairs via "+ Add Field" (Task 1)
- [ ] Metadata appears in both ScanBuilderPanel and ExperimentDesignerPanel (Tasks 2-3)
- [ ] Common fields are present but not required (empty strings allowed)
</verification>

<success_criteria>
**Measurable completion:**
1. MetadataEditor widget exists in widgets/metadata_editor.rs with ui() and to_metadata_map() methods
2. ScanBuilderPanel shows collapsible "Experiment Metadata" section
3. ExperimentDesignerPanel shows collapsible "Run Metadata" section
4. Building ScanBuilderPanel or ExperimentDesignerPanel with metadata entered produces QueuePlanRequest with enriched metadata HashMap
5. No clippy warnings in modified files

**Observable behaviors:**
- User opens ScanBuilderPanel, expands "Experiment Metadata", enters sample ID and notes
- User adds custom field "temperature" = "20C"
- User runs scan, metadata persists to StartDoc (verified in Phase 1's HDF5 writer)
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-management/06-01-SUMMARY.md` following the summary template with:
- Frontmatter: phase, plan, subsystem (ui), tags (metadata, widgets)
- Dependency graph: provides MetadataEditor widget, affects 06-02 (run history needs metadata)
- Tech stack: patterns (extensible key-value UI, metadata enrichment)
- Key files: created (metadata_editor.rs), modified (scan_builder.rs, experiment_designer.rs)
- Decisions: comma-separated tags vs structured list, auto-added provenance fields
</output>
