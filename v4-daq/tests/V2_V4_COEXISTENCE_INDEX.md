# V2/V4 Coexistence Integration Tests Index

**Test File**: `tests/v2_v4_coexistence_test.rs` (676 lines)
**Test Count**: 12 comprehensive integration tests
**All Tests**: PASSING (12/12)
**Execution Time**: ~410ms total

## Test File Organization

### Header (Lines 1-20)
```rust
//! V2/V4 Coexistence Integration Tests
//!
//! Tests for simultaneous operation of V2 and V4 runtimes:
//! - Dual runtime lifecycle (startup, concurrent operation, shutdown)
//! - V2 and V4 actors running together
//! - Data flow between V2 and V4 systems
//! - Error isolation between runtimes
```

### Imports (Lines 9-19)
- Core runtime: `tokio`, `Duration`, `timeout`
- V4 Actors: `ScpiActor`, `PVCAMActor`, `ESP300` (feature-gated)
- Utilities: `Arc`, `AtomicBool`, `Ordering`, `mpsc`
- Kameo: `Actor` trait

### Mock Components (Lines 25-150)

#### MockV2Actor (Lines 25-62)
- Simulates a V2 runtime actor
- Atomic state tracking with `Arc<AtomicBool>`
- Methods:
  - `new(id)` - Create actor instance
  - `initialize()` - Start the actor
  - `execute_command(cmd)` - Execute SCPI-like command
  - `shutdown()` - Stop the actor
  - `is_running()` - Query operational state

#### DualRuntimeManager (Lines 64-150)
- Orchestrates both V2 and V4 runtimes
- State machine: `Idle → Starting → Running → Stopping → Stopped`
- Methods:
  - `new()` - Create manager
  - `start()` - Start both runtimes
  - `shutdown(timeout)` - Graceful shutdown with timeout
  - `state()` - Query current state
  - `register_v2_actor(actor)` - Register V2 actor
  - `register_v4_actor(id)` - Register V4 actor
  - `v2_actor_count()` - Query V2 actor count
  - `v4_actor_count()` - Query V4 actor count

### Test Functions (Lines 152-680)

#### Test 1: Dual Runtime Startup/Shutdown (Lines 153-192)
```
Purpose: Verify both V2 and V4 runtimes can start and stop cleanly
Steps:
  1. Register 2 V2 mock actors and 2 V4 actor IDs
  2. Start the dual runtime manager
  3. Verify all V2 actors are running
  4. Execute graceful shutdown
  5. Verify all V2 actors are stopped
Result: PASSED
```

#### Test 2: Shutdown Timeout Enforcement (Lines 195-213)
```
Purpose: Verify shutdown timeouts are enforced
Steps:
  1. Create slow actor scenario
  2. Call shutdown with very short timeout (1ms)
  3. Verify state changes to Stopped
Result: PASSED
```

#### Test 3: V2/V4 Concurrent Actors (Lines 216-269)
```
Purpose: Verify V2 and V4 actors can run simultaneously
Steps:
  1. Start dual runtime with V2 actor
  2. Spawn V4 SCPI and PVCAM actors
  3. Execute concurrent commands on both systems
  4. Collect and verify results
Result: PASSED - Both systems operate independently
```

#### Test 4: V2→V4 Data Flow (Lines 271-308)
```
Purpose: Verify data generated by V2 can be consumed by V4
Steps:
  1. Create V2 data source (measurement)
  2. Create V4 PVCAM consumer (sensor)
  3. V2 generates measurement data
  4. V4 reads sensor capabilities
  5. Simulate data integration
Result: PASSED - Unidirectional V2→V4 flow works
```

#### Test 5: V4→V2 Data Flow (Lines 310-341)
```
Purpose: Verify data generated by V4 can be consumed by V2
Steps:
  1. Create V4 sensor data source (PVCAM)
  2. Create V2 data consumer
  3. V4 reads capabilities
  4. V2 stores the data
  5. Verify data transfer
Result: PASSED - Unidirectional V4→V2 flow works
```

#### Test 6: V2 Error Isolation (Lines 343-387)
```
Purpose: Verify V2 failures don't crash V4 actors
Steps:
  1. Start dual runtime with V4 SCPI and PVCAM
  2. Shutdown V2 actor (simulate error)
  3. Verify V4 actors still work
  4. Verify V2 is indeed down
Result: PASSED - V4 unaffected by V2 shutdown
```

#### Test 7: V4 Error Isolation (Lines 389-424)
```
Purpose: Verify V4 failures don't crash V2 actors
Steps:
  1. Start dual runtime with V2
  2. Spawn V4 PVCAM actor
  3. V2 works initially
  4. Kill V4 actor
  5. V2 continues working
Result: PASSED - V2 unaffected by V4 shutdown
```

#### Test 8: Concurrent Message Throughput (Lines 426-485)
```
Purpose: Verify both systems handle message burst loads
Steps:
  1. Spawn 10 concurrent V2 tasks
  2. Spawn 10 concurrent V4 tasks
  3. Execute all concurrently
  4. Count successes
Result: PASSED - 100% success rate (20/20 messages)
```

#### Test 9: Resource Contention (Lines 487-534)
```
Purpose: Verify graceful handling when systems compete for resources
Steps:
  1. Create 2 V2 actors
  2. Create 2 V4 PVCAM actors
  3. Execute concurrent operations
  4. Verify no interference
Result: PASSED - Resource contention handled gracefully
```

#### Test 10: Graceful Shutdown with Active Ops (Lines 536-581)
```
Purpose: Verify shutdown waits for in-flight operations
Steps:
  1. Start dual runtime
  2. Spawn 3 V2 and 3 V4 tasks
  3. Initiate shutdown while active
  4. Verify clean shutdown
Result: PASSED - Graceful shutdown works
```

#### Test 11: Bidirectional Communication (Lines 583-638)
```
Purpose: Verify V2 and V4 can communicate via message channels
Steps:
  1. Create MPSC channel
  2. V2 sends: "V2_DATA: measurement_123"
  3. V4 sends: "V4_DATA: capabilities"
  4. Receive and verify messages
Result: PASSED - Bidirectional communication works
```

#### Test 12: State Synchronization (Lines 640-680)
```
Purpose: Verify V2 and V4 can synchronize operational state
Steps:
  1. V4 reads sensor capabilities
  2. Extract sensor width value
  3. V2 records same state
  4. Verify format and consistency
Result: PASSED - State synchronization works
```

## Test Execution Summary

```
Test Results
============
Running Tests:      12
Passed:             12
Failed:             0
Ignored:            0
Success Rate:       100%
Execution Time:     ~410ms
Average per Test:   ~34ms

Test Order (Random):
  ✓ test_bidirectional_communication_channel
  ✓ test_concurrent_message_throughput
  ✓ test_data_flow_v2_to_v4
  ✓ test_data_flow_v4_to_v2
  ✓ test_dual_runtime_startup_shutdown
  ✓ test_graceful_shutdown_with_active_ops
  ✓ test_resource_contention
  ✓ test_shutdown_timeout_enforcement
  ✓ test_state_synchronization
  ✓ test_v2_and_v4_actors_concurrent
  ✓ test_v2_error_does_not_crash_v4
  ✓ test_v4_error_does_not_crash_v2

Status: SUCCESS - All tests passed
```

## Key Test Patterns

### 1. Actor Lifecycle
```rust
// Spawn V4 actor
let actor = ScpiActor::spawn(ScpiActor::mock("id".to_string()));

// Send messages
let result = actor.ask(Identify).await;

// Shutdown
actor.kill();
actor.wait_for_shutdown().await;
```

### 2. Error Handling
```rust
// Expect fallible operations
assert!(result.is_ok(), "Operation should succeed");
assert!(result.is_err(), "Operation should fail");

// Verify error properties
let error = result.unwrap_err();
```

### 3. Concurrent Operations
```rust
// Execute concurrently
let r1 = op1.await;
let r2 = op2.await;
let r3 = op3.await;

// Verify all succeeded
assert!(r1.is_ok() && r2.is_ok() && r3.is_ok());
```

### 4. Async/Await
```rust
// All test functions are async
#[tokio::test]
async fn test_name() {
    // Await futures
    let result = actor.ask(message).await;

    // Sleep for timing control
    tokio::time::sleep(Duration::from_millis(50)).await;
}
```

## Coverage Analysis

### V2 Subsystem Tests
- Lifecycle: ✓ (Test 1)
- Error Handling: ✓ (Test 6)
- Data Flow: ✓ (Tests 4, 5, 12)
- Concurrency: ✓ (Tests 3, 8, 9)
- Shutdown: ✓ (Tests 2, 10)

### V4 Subsystem Tests
- Lifecycle: ✓ (Test 1)
- Error Handling: ✓ (Test 7)
- Data Flow: ✓ (Tests 4, 5, 12)
- Concurrency: ✓ (Tests 3, 8, 9)
- Shutdown: ✓ (Tests 2, 10)

### Integration Tests
- Dual Runtime: ✓ (Tests 1, 2)
- Concurrent Operation: ✓ (Test 3)
- Data Exchange: ✓ (Tests 4, 5, 11, 12)
- Error Isolation: ✓ (Tests 6, 7)
- Resource Contention: ✓ (Test 9)
- Shutdown Coordination: ✓ (Test 10)

## Running the Tests

### All Tests
```bash
cargo test --test v2_v4_coexistence_test
```

### Specific Test
```bash
cargo test --test v2_v4_coexistence_test test_dual_runtime_startup_shutdown
```

### With Output
```bash
cargo test --test v2_v4_coexistence_test -- --nocapture --test-threads=1
```

### With Features
```bash
cargo test --test v2_v4_coexistence_test --features instrument_serial
```

## Documentation

- Full Report: `docs/V2_V4_COEXISTENCE_TEST_REPORT.md`
- Quick Summary: `docs/V2_V4_COEXISTENCE_SUMMARY.md`
- This Index: `tests/V2_V4_COEXISTENCE_INDEX.md`

## Conclusion

The V2/V4 coexistence integration test suite provides comprehensive coverage of dual-runtime scenarios, with all 12 tests passing successfully. The tests validate that V2 and V4 runtimes can operate simultaneously with proper isolation, communication, and lifecycle management.
