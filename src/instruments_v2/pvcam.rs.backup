//! Photometrics PVCAM camera driver V2 (PrimeBSI)
//!
//! V2 implementation using the new trait hierarchy and Measurement enum.
//! This enables native PixelBuffer::U16 broadcasting for 4× memory savings.
//!
//! ## Configuration
//!
//! ```toml
//! [instruments.prime_bsi]
//! type = "pvcam_v2"
//! camera_name = "PrimeBSI"
//! exposure_ms = 100.0
//! roi = [0, 0, 2048, 2048]  # [x, y, width, height]
//! binning = [1, 1]  # [x_bin, y_bin]
//! polling_rate_hz = 10.0
//! sdk_mode = "mock"  # or "real" when SDK available
//! ```

use async_trait::async_trait;
use chrono::Utc;
use daq_core::{
    arc_measurement, measurement_channel, Camera, DaqError, DataPoint, HardwareAdapter, ImageData,
    Instrument, InstrumentCommand, InstrumentState, Measurement, MeasurementReceiver,
    MeasurementSender, PixelBuffer, Result, ROI,
};
use tokio::task::JoinHandle;

use crate::adapters::MockAdapter;
use super::pvcam_sdk::{PvcamSdk, MockPvcamSdk, RealPvcamSdk, CameraHandle};

/// SDK mode selection for PVCAM camera
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PvcamSdkKind {
    /// Mock SDK for testing without hardware
    Mock,
    /// Real SDK for actual camera control
    Real,
}

/// PVCAM camera V2 implementation
///
/// Uses PixelBuffer::U16 for native 16-bit camera data (4× memory savings vs f64).
pub struct PVCAMInstrumentV2 {
    id: String,
    adapter: Box<dyn HardwareAdapter>,
    state: InstrumentState,
    
    // SDK abstraction layer
    sdk: Box<dyn PvcamSdk>,
    camera_handle: Option<CameraHandle>,

    // Camera configuration
    camera_name: String,
    exposure_ms: f64,
    roi: ROI,
    binning: (u16, u16),
    sensor_size: (u32, u32),

    // Data streaming
    measurement_tx: MeasurementSender,
    _measurement_rx_keeper: MeasurementReceiver,

    // Task management
    task_handle: Option<JoinHandle<()>>,
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
}

impl PVCAMInstrumentV2 {
    /// Create a new PVCAM instrument with default capacity (1024) and Mock SDK
    pub fn new(id: String) -> Self {
        Self::with_capacity(id, 1024)
    }

    /// Create a new PVCAM instrument with specified broadcast capacity and Mock SDK
    pub fn with_capacity(id: String, capacity: usize) -> Self {
        Self::with_sdk_and_capacity(id, PvcamSdkKind::Mock, capacity)
    }

    /// Create a new PVCAM instrument with custom adapter and capacity (Mock SDK)
    pub fn with_adapter_and_capacity(
        id: String,
        adapter: Box<dyn HardwareAdapter>,
        capacity: usize,
    ) -> Self {
        let (measurement_tx, measurement_rx) = measurement_channel(capacity);
        
        // Default to Mock SDK for backward compatibility
        let sdk: Box<dyn PvcamSdk> = Box::new(MockPvcamSdk::new());

        Self {
            id,
            adapter,
            state: InstrumentState::Disconnected,
            
            // SDK layer
            sdk,
            camera_handle: None,

            // Default PVCAM configuration
            camera_name: "PrimeBSI".to_string(),
            exposure_ms: 100.0,
            roi: ROI {
                x: 0,
                y: 0,
                width: 2048,
                height: 2048,
            },
            binning: (1, 1),
            sensor_size: (2048, 2048),

            measurement_tx,
            _measurement_rx_keeper: measurement_rx,

            task_handle: None,
            shutdown_tx: None,
        }
    }
    
    /// Create a new PVCAM instrument with specified SDK mode and capacity
    pub fn with_sdk_and_capacity(
        id: String,
        sdk_kind: PvcamSdkKind,
        capacity: usize,
    ) -> Self {
        let (measurement_tx, measurement_rx) = measurement_channel(capacity);
        
        // Create appropriate SDK implementation
        let sdk: Box<dyn PvcamSdk> = match sdk_kind {
            PvcamSdkKind::Mock => Box::new(MockPvcamSdk::new()),
            PvcamSdkKind::Real => Box::new(RealPvcamSdk::new()),
        };

        Self {
            id,
            adapter: Box::new(MockAdapter::new()),
            state: InstrumentState::Disconnected,
            
            // SDK layer
            sdk,
            camera_handle: None,

            // Default PVCAM configuration
            camera_name: "PrimeBSI".to_string(),
            exposure_ms: 100.0,
            roi: ROI {
                x: 0,
                y: 0,
                width: 2048,
                height: 2048,
            },
            binning: (1, 1),
            sensor_size: (2048, 2048),

            measurement_tx,
            _measurement_rx_keeper: measurement_rx,

            task_handle: None,
            shutdown_tx: None,
        }
    }

    /// Simulate frame data generation (placeholder for PVCAM SDK)
    ///
    /// TODO: Replace with actual PVCAM SDK calls:
    /// - pl_exp_start_seq()
    /// - pl_exp_check_status()
    /// - pl_exp_get_latest_frame()
    fn simulate_frame_data(&self, width: u32, height: u32) -> Vec<u16> {
        let mut frame = vec![0u16; (width * height) as usize];

        // Simple gradient pattern for testing
        for y in 0..height {
            for x in 0..width {
                let value = ((x + y) % 256) as u16 * 256;
                frame[(y * width + x) as usize] = value;
            }
        }

        frame
    }

    /// Calculate frame statistics
    fn calculate_frame_stats(&self, frame: &[u16]) -> (f64, f64, f64) {
        if frame.is_empty() {
            return (0.0, 0.0, 0.0);
        }

        let sum: u64 = frame.iter().map(|&v| v as u64).sum();
        let mean = sum as f64 / frame.len() as f64;

        let min = *frame.iter().min().unwrap_or(&0) as f64;
        let max = *frame.iter().max().unwrap_or(&0) as f64;

        (mean, min, max)
    }
    
    /// Get the camera handle, returning an error if not initialized
    fn get_handle(&self) -> Result<CameraHandle> {
        self.camera_handle
            .ok_or_else(|| anyhow::anyhow!("Camera not initialized"))
    }
    
    /// Convert our ROI struct to PVCAM PxRegion
    fn roi_to_px_region(&self, roi: &ROI, binning: (u16, u16)) -> super::pvcam_sdk::PxRegion {
        use super::pvcam_sdk::PxRegion;
        PxRegion {
            s1: roi.x,
            s2: roi.x + roi.width - 1,
            sbin: binning.0,
            p1: roi.y,
            p2: roi.y + roi.height - 1,
            pbin: binning.1,
        }
    }
    
    /// Convert PVCAM PxRegion to our ROI struct
    fn px_region_to_roi(&self, region: &super::pvcam_sdk::PxRegion) -> (ROI, (u16, u16)) {
        let roi = ROI {
            x: region.s1,
            y: region.p1,
            width: region.s2 - region.s1 + 1,
            height: region.p2 - region.p1 + 1,
        };
        let binning = (region.sbin, region.pbin);
        (roi, binning)
    }
}

#[async_trait]
impl Instrument for PVCAMInstrumentV2 {
    fn id(&self) -> &str {
        &self.id
    }

    fn instrument_type(&self) -> &str {
        "pvcam_v2"
    }

    fn state(&self) -> InstrumentState {
        self.state.clone()
    }

    async fn initialize(&mut self) -> Result<()> {
        if self.state != InstrumentState::Disconnected {
            return Err(anyhow::anyhow!("Already initialized"));
        }

        self.state = InstrumentState::Connecting;

        // Initialize PVCAM SDK
        self.sdk.init().map_err(|e| {
            anyhow::anyhow!("Failed to initialize PVCAM SDK: {}", e)
        })?;
        
        // Open camera
        let handle = self.sdk.open_camera(&self.camera_name).map_err(|e| {
            let _ = self.sdk.uninit(); // Cleanup on failure
            anyhow::anyhow!("Failed to open camera '{}': {}", self.camera_name, e)
        })?;
        
        self.camera_handle = Some(handle);
        
        log::info!(
            "PVCAM SDK initialized, camera '{}' opened with handle {:?}",
            self.camera_name,
            handle
        );

        // Initialize hardware adapter (for compatibility)
        match self.adapter.connect(&Default::default()).await {
            Ok(()) => {
                self.state = InstrumentState::Ready;
                log::info!(
                    "PVCAM camera '{}' ({}) initialized",
                    self.id,
                    self.camera_name
                );
                Ok(())
            }
            Err(e) => {
                // Cleanup SDK on adapter failure
                if let Some(handle) = self.camera_handle.take() {
                    let _ = self.sdk.close_camera(handle);
                }
                let _ = self.sdk.uninit();
                
                self.state = InstrumentState::Error(DaqError {
                    message: e.to_string(),
                    can_recover: true,
                });
                Err(e)
            }
        }
    }

    async fn shutdown(&mut self) -> Result<()> {
        self.state = InstrumentState::ShuttingDown;

        // Stop any running acquisition
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        if let Some(handle) = self.task_handle.take() {
            let _ = handle.await;
        }

        // Close camera and uninitialize SDK
        if let Some(handle) = self.camera_handle.take() {
            self.sdk.close_camera(handle).map_err(|e| {
                log::error!("Failed to close camera: {}", e);
                anyhow::anyhow!("Failed to close camera: {}", e)
            })?;
            log::info!("PVCAM camera handle {:?} closed", handle);
        }
        
        self.sdk.uninit().map_err(|e| {
            log::error!("Failed to uninitialize PVCAM SDK: {}", e);
            anyhow::anyhow!("Failed to uninitialize PVCAM SDK: {}", e)
        })?;
        
        log::info!("PVCAM SDK uninitialized");

        self.adapter.disconnect().await?;

        self.state = InstrumentState::Disconnected;
        log::info!("PVCAM camera '{}' shut down", self.id);
        Ok(())
    }

    fn measurement_stream(&self) -> MeasurementReceiver {
        self.measurement_tx.subscribe()
    }

    async fn handle_command(&mut self, cmd: InstrumentCommand) -> Result<()> {
        match cmd {
            InstrumentCommand::Shutdown => self.shutdown().await,
            InstrumentCommand::StartAcquisition => self.start_live().await,
            InstrumentCommand::StopAcquisition => self.stop_live().await,
            InstrumentCommand::SetParameter { name, value } => match name.as_str() {
                "exposure_ms" => {
                    if let Some(ms) = value.as_f64() {
                        self.set_exposure_ms(ms).await
                    } else {
                        Err(anyhow::anyhow!("Invalid exposure value"))
                    }
                }
                "gain" => {
                    if let Some(gain_f64) = value.as_f64() {
                        let gain_u16 = gain_f64 as u16;
                        let handle = self.get_handle()?;
                        self.sdk
                            .set_param_u16(&handle, super::pvcam_sdk::PvcamParam::Gain, gain_u16)
                            .map_err(|e| anyhow::anyhow!("Failed to set gain: {}", e))?;
                        log::info!("PVCAM gain set to {}", gain_u16);
                        Ok(())
                    } else {
                        Err(anyhow::anyhow!("Invalid gain value"))
                    }
                }
                "binning" => {
                    // TODO: Parse binning value from JSON and call set_binning
                    log::info!("PVCAM binning set to {}", value);
                    Ok(())
                }
                _ => Err(anyhow::anyhow!("Unknown parameter: {}", name)),
            },
            InstrumentCommand::GetParameter { .. } => {
                // Not implemented yet
                Ok(())
            }
            InstrumentCommand::Recover => self.recover().await,
        }
    }

    async fn recover(&mut self) -> Result<()> {
        match &self.state {
            InstrumentState::Error(daq_error) if daq_error.can_recover => {
                log::info!("Attempting recovery for PVCAM '{}'", self.id);

                let _ = self.adapter.disconnect().await;
                tokio::time::sleep(std::time::Duration::from_millis(500)).await;

                self.adapter.connect(&Default::default()).await?;

                self.state = InstrumentState::Ready;
                log::info!("Recovery successful for PVCAM '{}'", self.id);
                Ok(())
            }
            InstrumentState::Error(_) => {
                Err(anyhow::anyhow!("Cannot recover from unrecoverable error"))
            }
            _ => Err(anyhow::anyhow!(
                "Cannot recover from state: {:?}",
                self.state
            )),
        }
    }
}

#[async_trait]
impl Camera for PVCAMInstrumentV2 {
    async fn snap(&mut self) -> Result<ImageData> {
        if self.state != InstrumentState::Ready {
            return Err(anyhow::anyhow!(
                "PVCAM camera not ready, state: {:?}",
                self.state
            ));
        }

        self.state = InstrumentState::Acquiring;

        // Simulate acquisition delay
        tokio::time::sleep(std::time::Duration::from_millis(self.exposure_ms as u64)).await;

        let width = (self.roi.width / self.binning.0) as u32;
        let height = (self.roi.height / self.binning.1) as u32;

        // Generate u16 frame data (native camera format)
        let frame_data = self.simulate_frame_data(width, height);

        // ✅ KEY FEATURE: Use PixelBuffer::U16 for 4× memory savings!
        let image = ImageData {
            timestamp: Utc::now(),
            channel: format!("{}_image", self.id),
            width,
            height,
            pixels: PixelBuffer::U16(frame_data), // 4× memory reduction vs Vec<f64>
            unit: "counts".to_string(),
            metadata: Some(serde_json::json!({
                "camera_name": self.camera_name,
                "exposure_ms": self.exposure_ms,
                "roi": self.roi,
                "binning": self.binning,
            })),
        };

        // Emit measurement
        let measurement = arc_measurement(Measurement::Image(image.clone()));
        let _ = self.measurement_tx.send(measurement);

        self.state = InstrumentState::Ready;

        Ok(image)
    }

    async fn start_live(&mut self) -> Result<()> {
        if self.state != InstrumentState::Ready {
            return Err(anyhow::anyhow!(
                "Cannot start live from state: {:?}",
                self.state
            ));
        }

        self.state = InstrumentState::Acquiring;

        let tx = self.measurement_tx.clone();
        let id = self.id.clone();
        let camera_name = self.camera_name.clone();
        let exposure_ms = self.exposure_ms;
        let roi = self.roi;
        let binning = self.binning;

        let (shutdown_tx, mut shutdown_rx) = tokio::sync::oneshot::channel();
        self.shutdown_tx = Some(shutdown_tx);

        // Spawn continuous acquisition task
        self.task_handle = Some(tokio::spawn(async move {
            let width = (roi.width / binning.0) as u32;
            let height = (roi.height / binning.1) as u32;
            let mut frame_count = 0u64;

            log::info!("PVCAM live acquisition started for '{}'", id);

            // Broadcast acquiring status = 1.0 (acquiring)
            let acquiring_status = DataPoint {
                timestamp: Utc::now(),
                channel: format!("{}:acquiring", id),
                value: 1.0,
                unit: "".to_string(),
            };
            let _ = tx.send(arc_measurement(Measurement::Scalar(acquiring_status)));

            loop {
                tokio::select! {
                    // Simulate frame acquisition
                    _ = tokio::time::sleep(std::time::Duration::from_millis(exposure_ms as u64)) => {
                        frame_count += 1;

                        // Generate u16 frame (simulating PVCAM SDK output)
                        let mut frame_data = vec![0u16; (width * height) as usize];
                        
                        // Simple PRNG for noise (using frame_count as seed)
                        let mut rng_state = frame_count.wrapping_mul(1103515245).wrapping_add(12345);
                        
                        // Add frame-varying offset to make pattern move
                        let frame_offset = (frame_count % 256) as u32;
                        
                        for y in 0..height {
                            for x in 0..width {
                                // Base gradient pattern with frame animation
                                let base_value = ((x + y + frame_offset) % 256) as u16 * 100;
                                
                                // Add significant noise (±5000 counts, ~15% of max)
                                rng_state = rng_state.wrapping_mul(1103515245).wrapping_add(12345);
                                let noise = ((rng_state >> 16) % 10000) as i32 - 5000;
                                let value = (base_value as i32 + noise).clamp(0, 65535) as u16;
                                
                                frame_data[(y * width + x) as usize] = value;
                            }
                        }

                        // Calculate statistics
                        let sum: u64 = frame_data.iter().map(|&v| v as u64).sum();
                        let mean = sum as f64 / frame_data.len() as f64;
                        let min = *frame_data.iter().min().unwrap_or(&0) as f64;
                        let max = *frame_data.iter().max().unwrap_or(&0) as f64;

                        let timestamp = Utc::now();

                        // Emit image measurement with PixelBuffer::U16
                        let image = ImageData {
                            timestamp,
                            channel: format!("{}_image", id),
                            width,
                            height,
                            pixels: PixelBuffer::U16(frame_data), // ✅ 4× memory savings
                            unit: "counts".to_string(),
                            metadata: Some(serde_json::json!({
                                "camera_name": camera_name,
                                "exposure_ms": exposure_ms,
                                "roi": roi,
                                "binning": binning,
                                "frame": frame_count,
                            })),
                        };

                        let measurement = arc_measurement(Measurement::Image(image));
                        if tx.send(measurement.clone()).is_err() {
                            log::info!("No receivers for image, stopping acquisition");
                            break;
                        }

                        // Also emit scalar statistics (using colon separator for GUI compatibility)
                        let dp_mean = DataPoint {
                            timestamp,
                            channel: format!("{}:mean_intensity", id),
                            value: mean,
                            unit: "counts".to_string(),
                        };
                        let _ = tx.send(arc_measurement(Measurement::Scalar(dp_mean)));

                        let dp_min = DataPoint {
                            timestamp,
                            channel: format!("{}:min_intensity", id),
                            value: min,
                            unit: "counts".to_string(),
                        };
                        let _ = tx.send(arc_measurement(Measurement::Scalar(dp_min)));

                        let dp_max = DataPoint {
                            timestamp,
                            channel: format!("{}:max_intensity", id),
                            value: max,
                            unit: "counts".to_string(),
                        };
                        let _ = tx.send(arc_measurement(Measurement::Scalar(dp_max)));
                    }
                    // Shutdown signal
                    _ = &mut shutdown_rx => {
                        log::info!("PVCAM acquisition shutdown requested for '{}'", id);
                        break;
                    }
                }
            }

            // Broadcast acquiring status = 0.0 (idle) when loop exits
            let idle_status = DataPoint {
                timestamp: Utc::now(),
                channel: format!("{}:acquiring", id),
                value: 0.0,
                unit: "".to_string(),
            };
            let _ = tx.send(arc_measurement(Measurement::Scalar(idle_status)));

            log::info!("PVCAM live acquisition stopped for '{}'", id);
        }));

        Ok(())
    }

    async fn stop_live(&mut self) -> Result<()> {
        if self.state != InstrumentState::Acquiring {
            return Ok(()); // Already stopped
        }

        // Signal shutdown
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        // Wait for task to finish
        if let Some(handle) = self.task_handle.take() {
            let _ = handle.await;
        }

        self.state = InstrumentState::Ready;
        log::info!("Stopped live acquisition for PVCAM '{}'", self.id);
        Ok(())
    }

    async fn set_exposure_ms(&mut self, ms: f64) -> Result<()> {
        if self.state == InstrumentState::Acquiring {
            return Err(anyhow::anyhow!("Cannot change exposure while acquiring"));
        }
        
        // Convert f64 milliseconds to u16 for SDK (PVCAM uses integer milliseconds)
        let exposure_u16 = ms as u16;
        
        let handle = self.get_handle()?;
        self.sdk
            .set_param_u16(&handle, super::pvcam_sdk::PvcamParam::Exposure, exposure_u16)
            .map_err(|e| anyhow::anyhow!("Failed to set exposure: {}", e))?;
        
        self.exposure_ms = ms;
        log::info!("PVCAM exposure set to {} ms", ms);
        Ok(())
    }

    async fn get_exposure_ms(&self) -> f64 {
        self.exposure_ms
    }

    async fn set_roi(&mut self, roi: ROI) -> Result<()> {
        if self.state == InstrumentState::Acquiring {
            return Err(anyhow::anyhow!("Cannot change ROI while acquiring"));
        }
        
        let handle = self.get_handle()?;
        let px_region = self.roi_to_px_region(&roi, self.binning);
        
        self.sdk
            .set_param_region(&handle, super::pvcam_sdk::PvcamParam::Roi, px_region)
            .map_err(|e| anyhow::anyhow!("Failed to set ROI: {}", e))?;
        
        self.roi = roi;
        log::info!("PVCAM ROI set to {:?}", roi);
        Ok(())
    }

    async fn get_roi(&self) -> ROI {
        self.roi
    }

    async fn set_binning(&mut self, x: u16, y: u16) -> Result<()> {
        if self.state == InstrumentState::Acquiring {
            return Err(anyhow::anyhow!("Cannot change binning while acquiring"));
        }
        
        let handle = self.get_handle()?;
        let px_region = self.roi_to_px_region(&self.roi, (x, y));
        
        // Update ROI with new binning
        self.sdk
            .set_param_region(&handle, super::pvcam_sdk::PvcamParam::Roi, px_region)
            .map_err(|e| anyhow::anyhow!("Failed to set binning: {}", e))?;
        
        self.binning = (x, y);
        log::info!("PVCAM binning set to ({}, {})", x, y);
        Ok(())
    }

    async fn get_binning(&self) -> (u16, u16) {
        self.binning
    }

    fn get_sensor_size(&self) -> (u32, u32) {
        self.sensor_size
    }

    fn get_pixel_size_um(&self) -> (f64, f64) {
        (6.5, 6.5) // PrimeBSI pixel size
    }

    fn supports_hardware_trigger(&self) -> bool {
        true // PVCAM supports hardware triggering
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_pvcam_lifecycle() {
        let mut camera = PVCAMInstrumentV2::new("test_pvcam".to_string());

        assert_eq!(camera.state(), InstrumentState::Disconnected);

        camera.initialize().await.unwrap();
        assert_eq!(camera.state(), InstrumentState::Ready);

        camera.shutdown().await.unwrap();
        assert_eq!(camera.state(), InstrumentState::Disconnected);
    }

    #[tokio::test]
    async fn test_pvcam_snap_uses_pixelbuffer_u16() {
        let mut camera = PVCAMInstrumentV2::new("test_pvcam".to_string());
        camera.initialize().await.unwrap();

        let image = camera.snap().await.unwrap();

        // Verify PixelBuffer::U16 is used
        match image.pixels {
            PixelBuffer::U16(ref data) => {
                assert_eq!(data.len(), 2048 * 2048);
                // Verify u16 values are in valid range
                assert!(data.iter().all(|&v| v <= u16::MAX));
            }
            _ => panic!("Expected PixelBuffer::U16, got {:?}", image.pixels),
        }

        // Verify memory savings
        let actual_bytes = image.pixels.memory_bytes();
        let expected_bytes = 2048 * 2048 * 2; // u16 = 2 bytes/pixel
        assert_eq!(actual_bytes, expected_bytes);

        // Compare to old Vec<f64> approach
        let old_bytes = 2048 * 2048 * 8; // f64 = 8 bytes/pixel
        let savings = old_bytes - actual_bytes;
        assert_eq!(savings, 25165824); // 24 MB savings per frame!
    }

    #[tokio::test]
    async fn test_pvcam_live_acquisition() {
        let mut camera = PVCAMInstrumentV2::new("test_pvcam".to_string());
        camera.initialize().await.unwrap();

        let mut rx = camera.measurement_stream();

        camera.start_live().await.unwrap();
        assert_eq!(camera.state(), InstrumentState::Acquiring);

        // Receive a few measurements (mix of Image and Scalar)
        for _ in 0..10 {
            let measurement = rx.recv().await.unwrap();
            match &*measurement {
                Measurement::Image(image) => {
                    // Verify PixelBuffer::U16
                    assert!(matches!(image.pixels, PixelBuffer::U16(_)));
                }
                Measurement::Scalar(data) => {
                    // Statistics channels and status channel
                    assert!(
                        data.channel.contains("mean")
                            || data.channel.contains("min")
                            || data.channel.contains("max")
                            || data.channel.contains("acquiring")
                    );
                }
                _ => panic!("Unexpected measurement type"),
            }
        }

        camera.stop_live().await.unwrap();
        assert_eq!(camera.state(), InstrumentState::Ready);
    }
}